<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>换了电脑，怎么做 hexo 数据迁移？</title>
      <link href="/2019/06/15/%E6%8D%A2%E4%BA%86%E7%94%B5%E8%84%91%EF%BC%8C%E6%80%8E%E4%B9%88%E5%81%9A-hexo-%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%EF%BC%9F/"/>
      <url>/2019/06/15/%E6%8D%A2%E4%BA%86%E7%94%B5%E8%84%91%EF%BC%8C%E6%80%8E%E4%B9%88%E5%81%9A-hexo-%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>使用 hexo 搭建博客的时候，我们的网页数据都存在了本地电脑上，更换电脑时，需要我们做一个同步。我们需要同步的文件并不多：</p><ol><li>source 文件夹         含有我们网站的源文件</li><li>_config.yml 文件      网站的配置文件</li><li>theme 文件夹          主题</li></ol><p>接下来就是实际更换流程：</p><ol><li>在新电脑上配置 hexo 环境，按照 hexo 网站教程，搭建环境，并且将 github 支持完成。</li><li>覆盖掉上述文件。</li></ol><p>整个替换流程就是这么简单。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OAStackView</title>
      <link href="/2018/12/19/OAStackView/"/>
      <url>/2018/12/19/OAStackView/</url>
      
        <content type="html"><![CDATA[<h2 id="UIStackView-的理解"><a href="#UIStackView-的理解" class="headerlink" title="UIStackView 的理解"></a>UIStackView 的理解</h2><p><code>UIStackView</code> 是 <code>iOS9</code> 推出的新特性，允许我们线性的去布局一个界面，在之前没有用到过，但是新公司用到的地方挺多，所以写一篇文章介绍一下，也加深自己的理解。<br>使用 <code>UIStackView</code> 布局，允许我们通过设置 <code>stackView</code> 的属性，从而不必再去设置子<code>view</code>的约束，减少我们的代码量。当然，这只是某种情况下，有时候我们还是需要设置约束的。  </p><h2 id="StackView-属性"><a href="#StackView-属性" class="headerlink" title="StackView 属性"></a>StackView 属性</h2><p>使用 <code>UIStackView</code>，最多的是跟他的属性打交道:</p><ul><li>axis    定义子<code>view</code>的排列方向，横向或竖向</li><li>distribution 定义子<code>view</code>在排列方向上的填充规则，充满，等宽等。</li><li>alignment 定义子<code>view</code>在垂直于排列方向上的填充规则，充满，左对齐，上对齐等。</li><li>spacing 定义子<code>view</code>之间的 space。</li></ul><p>### </p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSURLProtocol</title>
      <link href="/2018/12/17/NSURLProtocol/"/>
      <url>/2018/12/17/NSURLProtocol/</url>
      
        <content type="html"><![CDATA[<p>在 Apple 的文档 <code>URL Loading System</code> 中，详细介绍了一个请求是如何创建、发起、回传数据的，还包括了证书认证，cookie 等一系列的操作，但是好像唯独遗漏了一个特殊的类： <code>NSURLProtocol</code> ，其实在我们日常开发中，是有可能需要跟这个类打交道的，比如网页的缓存，request 重定向等一系列的需求。 <a id="more"></a></p><h2 id="关于-Apple-对-NSURLProtocol-的介绍"><a href="#关于-Apple-对-NSURLProtocol-的介绍" class="headerlink" title="关于 Apple 对 NSURLProtocol 的介绍"></a>关于 Apple 对 NSURLProtocol 的介绍</h2><p>每次发起请求时，系统会寻找或者创建一个合适的 <code>protocol</code> 对象来响应 <code>request</code>，而在 <code>protocol</code>中，有一系列的方法会被调用，用来确定是否能够响应这次请求，并且允许通过返回参数来替换原本的请求。<br><code>NSURLProtocol</code>是一个抽象类，里面定义许多发起请求时，系统自动回调的方法。我们需要创建一个继承自 <code>NSURLProtocol</code>的子类，并且实现某些方法，并且将类注册到系统中。系统发起请求时，按照注册的顺序，倒序询问所有的 protocol，假如能处理这次请求的话，就将处理转到这个类中。  </p><h2 id="创建一个-Protocol-对象"><a href="#创建一个-Protocol-对象" class="headerlink" title="创建一个 Protocol 对象"></a>创建一个 Protocol 对象</h2><h3 id="initWithRequest-cachedResponse-client"><a href="#initWithRequest-cachedResponse-client" class="headerlink" title="- initWithRequest:cachedResponse:client:"></a>- initWithRequest:cachedResponse:client:</h3><h3 id="initWithTask-cachedResponse-client"><a href="#initWithTask-cachedResponse-client" class="headerlink" title="- initWithTask:cachedResponse:client:"></a>- initWithTask:cachedResponse:client:</h3><p>当我们想在初始化的时候，自定义一些操作的话，我们可以重写上面这俩个方法，但是我们不需要手动调用初始化方法生成对象，这两个方法是系统会自动调用的。</p><h2 id="向系统中注册-Protocol-类"><a href="#向系统中注册-Protocol-类" class="headerlink" title="向系统中注册 Protocol 类"></a>向系统中注册 Protocol 类</h2><h3 id="BOOL-registerClass-Class-protocolClass"><a href="#BOOL-registerClass-Class-protocolClass" class="headerlink" title="+ (BOOL)registerClass:(Class)protocolClass"></a>+ (BOOL)registerClass:(Class)protocolClass</h3><p>向系统中注册我们自定义的 <code>protocol</code>，只有这个类不是 <code>NSURLProtocol</code>子类时，这个方法才会返回 NO。当系统发起一次请求时，会按照注册顺序，倒序的调用子类的方法：<code>canInitWithRequest</code> ，第一个返回 YES 的类，会被确定为这次响应的 protocol。  </p><h3 id="Important"><a href="#Important" class="headerlink" title="Important"></a>Important</h3><p>需要注意的是，当我们用<code>NSURLProtocol</code>发起请求时，注册方法应该如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">configuration.protocolClasses = @[objc_getClass(<span class="string">"CustomURLProtocol"</span>)];</span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class="keyword">self</span> delegateQueue:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>需要将自定义的 protocol 注册到 session 的 configuration.protocolClasses 中，才能起作用。</p><h3 id="void-unregisterClass-Class-protocolClass"><a href="#void-unregisterClass-Class-protocolClass" class="headerlink" title="+ (void)unregisterClass:(Class)protocolClass"></a>+ (void)unregisterClass:(Class)protocolClass</h3><p>这个方法调用后，该类不再被系统询问。</p><h2 id="决定一个-NSURLProtocol-子类是否支持响应某个-request"><a href="#决定一个-NSURLProtocol-子类是否支持响应某个-request" class="headerlink" title="决定一个 NSURLProtocol 子类是否支持响应某个 request"></a>决定一个 NSURLProtocol 子类是否支持响应某个 request</h2><h3 id="BOOL-canInitWithRequest-NSURLRequest-request"><a href="#BOOL-canInitWithRequest-NSURLRequest-request" class="headerlink" title="+ (BOOL)canInitWithRequest:(NSURLRequest *)request"></a>+ (BOOL)canInitWithRequest:(NSURLRequest *)request</h3><p>一个子类必须实现这个方法，来告诉系统，是否由该子类响应这次请求，返回 YES 的话，系统创建该类的对象，并且后续的类方法和对象方法会继续被回调，，返回 NO 的话，系统越过该子类，继续查找。</p><h3 id="BOOL-canInitWithTask"><a href="#BOOL-canInitWithTask" class="headerlink" title="+ (BOOL)canInitWithTask"></a>+ (BOOL)canInitWithTask</h3><p>使用 <code>NSURLSession</code>发起请求时，会先调用这个方法，yes 的话，继续调用上面那个方法。功能与上线方法类似。</p><h2 id="提供给系统一个标准化的-request"><a href="#提供给系统一个标准化的-request" class="headerlink" title="提供给系统一个标准化的 request"></a>提供给系统一个标准化的 request</h2><p>假如一个子类可以响应一个请求，系统会继续调用下面的方法：</p><h3 id="NSURLRequest-canonicalRequestForRequest-NSURLRequest-request"><a href="#NSURLRequest-canonicalRequestForRequest-NSURLRequest-request" class="headerlink" title="+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request"></a>+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request</h3><p>在这个方法中，我们可以返回一个自定义的 request，系统会替换原有的，也可以直接返回原有的 request。</p><h2 id="开始和停止请求"><a href="#开始和停止请求" class="headerlink" title="开始和停止请求"></a>开始和停止请求</h2><h3 id="void-startLoading"><a href="#void-startLoading" class="headerlink" title="- (void)startLoading"></a>- (void)startLoading</h3><p>当这个方法被调用时，子类必须发起请求，并通过 client ，将数据回传给系统，系统再将数据传递给本来的监听者。</p><h3 id="void-stopLoading"><a href="#void-stopLoading" class="headerlink" title="- (void)stopLoading"></a>- (void)stopLoading</h3><p>这个方法被调用时，子类需要停止自己的请求。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个类是比较简单的一个类，可以当成是，苹果允许的一个中间人攻击，当发起一个请求时，我们可以通过注册 protocol ，替换这次请求，发起我们自己的请求，并通过 client ，将数据传给系统，这一切对 urlSessionDelegate 来说都是透明的。<br><a href="../NSURLProtocol/NSURLProtocol.png">简单的数据流通图</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 下的 https 单向和双向认证</title>
      <link href="/2018/12/07/iOS-%E4%B8%8B%E7%9A%84-https-%E5%8D%95%E5%90%91%E5%92%8C%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/"/>
      <url>/2018/12/07/iOS-%E4%B8%8B%E7%9A%84-https-%E5%8D%95%E5%90%91%E5%92%8C%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<p>iOS 操作系统，已经对请求中的认证需求(有的文章中称为 挑战)，做了简单的处理。当我们使用<code>NSURLSession</code>发起一次请求时，假如服务端返回数据要求客户端进行需求认证，不管这次需求认证是 HTTP Basic 类型(例如要求输入用户名/密码)、 ServerTrust 类型(对服务器的一个认证，单向认证)，或者是 ClientCertificate 类型(对客户端的认证，双向认证)，最终都会回调下面这个方法：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler;</span><br></pre></td></tr></table></figure><p>通过实现这个代理方法，我们可以使我们的 app 支持 https 请求，并且可以进行我们自定义的认证。一般来说，对于其他类型的需求认证，我们会让系统进行默认处理，只有我们需要验证服务端证书，或者双向认证时，我们才会实现这个代理方法。包括 AF 对于 https 请求的处理，也是针对于此方法的封装。  </p><h2 id="相关基本概念"><a href="#相关基本概念" class="headerlink" title="相关基本概念"></a>相关基本概念</h2><p>不管 https 单向认证还是双向认证，都有两个目的：  </p><ol><li>协商对称加密密钥  </li><li>数据加密传输  </li></ol><p>一般来说，所谓单向认证和双向认证的区别，只是在第一步，协商对称加密密钥时，服务器对于客户端是否做证书验证。<br>iOS 操作系统切入点是在 协商对称加密密钥 中的 身份验证阶段，通过回调代理方法，将控制权交给 app 。  </p><p>代理方法传入的参数中，包含了这次认证需求的类型，包括 对服务器的认证(单向认证ServerTrust) 或者 对客户端证书的需求(ClientCertificate) 。我们在代理方法中可以验证服务器的证书，并通过调用传入的 <code>completionBlock</code> 来传入系统需要的参数。</p><h3 id="单向认证"><a href="#单向认证" class="headerlink" title="单向认证"></a>单向认证</h3><p>先看一下单向认证的流程：  </p><ol><li>客户端 A 向 服务端 B 发起请求，传输了 A 所支持的 SSL/TLS 协议版本列表、支持的对称加密算法列表、随机数 a。</li><li>B 选择一个 SSL/TLS 协议版本、对称加密算法、包含自己公钥的证书、随机数 b 发送给 A。</li><li>A 对 B 发送的 证书 进行验证，包括 域名是否一致、证书是否过期吊销、证书是否可信。对于证书是否可信，设备中一般会有一个证书信任列表，存储了这些证书机构的公钥，证书中包含了对 B 公钥的加密，和机构对信息的签名，设备用机构的公钥进行验签，验证通过则代表 B 公钥的可信度。这时候 A 生成一个随机数，使用 B 公钥进行加密，传输给 B 。</li><li>最后一步，B 用自己的私钥解密，得到 c ，这时候A he B 都得到了 a b c，使用 a b c 生成对称加密的密钥，后续中就使用这个密钥进行数据加密传输。</li></ol><p>在第 3 步，验证证书的时候，系统会回调代理方法，假如我们服务器的证书，是通过正规渠道申请的，即使不实现这个代理方法，系统也会对证书进行验证。<br>当我们使用自签证书时，系统的证书信任列表中没有这个证书相关信息，我们就必须实现这个代理方法，否则会报错。  </p><h3 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h3><p>区别在于服务端会对客户端进行验证，主要是第 3 步 和 第 4 步</p><ol><li>~</li><li>~</li><li>A 对 B 的证书进行验证通过后，将信息使用自己的私钥进行加密，并将自己的证书一起传输到 B。</li><li>B 对 A 发送过来的证书进行验证，通过后取出 A 的公钥，对信息进行解密，得到 c ，生成对称加密密钥。</li></ol><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="单向认证-1"><a href="#单向认证-1" class="headerlink" title="单向认证"></a>单向认证</h3><p>具体的代码如下，这里使用 AF ，其实都一样， AF 只不过做了简单的封装。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">    __block NSURLCredential *credential = nil;</span><br><span class="line"></span><br><span class="line">    if (self.sessionDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">     /// 允许使用者自定义处理方式，双向认证的时候会用到。</span><br><span class="line">        disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /// 判断这次认证需求的类型是否是 https 中的 对服务端认证，不是的话让系统进行默认处理。</span><br><span class="line">        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                /// 上面这个方法是根据配置，对服务端证书进行认证，认证通过的话，创建证书并回调。</span><br><span class="line">                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">                if (credential) &#123;</span><br><span class="line">                    disposition = NSURLSessionAuthChallengeUseCredential;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               /// 认证没有通过，取消这次认证需求，请求随之取消。</span><br><span class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再查看一下验证服务端证书的具体方法实现，首先要清楚的是，证书验证包括域名一致验证，证书有效验证，公钥验证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust</span><br><span class="line">                  forDomain:(NSString *)domain</span><br><span class="line">&#123;</span><br><span class="line">    if (domain &amp;&amp; self.allowInvalidCertificates &amp;&amp; self.validatesDomainName &amp;&amp; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) &#123;</span><br><span class="line">        // https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html</span><br><span class="line">        //  According to the docs, you should only trust your provided certs for evaluation.</span><br><span class="line">        //  Pinned certificates are added to the trust. Without pinned certificates,</span><br><span class="line">        //  there is nothing to evaluate against.</span><br><span class="line">        //</span><br><span class="line">        //  From Apple Docs:</span><br><span class="line">        //          &quot;Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors).</span><br><span class="line">        //           Instead, add your own (self-signed) CA certificate to the list of trusted anchors.&quot;</span><br><span class="line">        NSLog(@&quot;In order to validate a domain name for self signed certificates, you MUST use pinning.&quot;);</span><br><span class="line">        /// 假如我们配置的需要验证域名，那么 SSLPinningNode 就不能设置为 None，必须设置为其他类型。</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">/// 是否验证域名，假如验证域名，将域名添加到验证条件中。</span><br><span class="line">    NSMutableArray *policies = [NSMutableArray array];</span><br><span class="line">    if (self.validatesDomainName) &#123;</span><br><span class="line">        [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies);</span><br><span class="line">/// 假如验证模式设置为 None ，代表无条件信任服务端，直接返回证书有效验证结果，假如我们选择允许无效证书，直接返回 YES，通过这次验证。</span><br><span class="line">    if (self.SSLPinningMode == AFSSLPinningModeNone) &#123;</span><br><span class="line">        return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</span><br><span class="line">    &#125; else if (!AFServerTrustIsValid(serverTrust) &amp;&amp; !self.allowInvalidCertificates) &#123;</span><br><span class="line">    /// 假如证书无效，且不允许无效证书，返回 NO。</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">/// 针对不同验证模式进行不同处理</span><br><span class="line">    switch (self.SSLPinningMode) &#123;</span><br><span class="line">        case AFSSLPinningModeNone:</span><br><span class="line">        /// 不验证，上面已经进行了处理。</span><br><span class="line">        default:</span><br><span class="line">            return NO;</span><br><span class="line">        case AFSSLPinningModeCertificate: &#123;</span><br><span class="line">        /// 验证证书模式，对证书中的全部内容进行验证，会验证证书有效性，证书是否一致。</span><br><span class="line">            NSMutableArray *pinnedCertificates = [NSMutableArray array];</span><br><span class="line">            for (NSData *certificateData in self.pinnedCertificates) &#123;</span><br><span class="line">                [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)];</span><br><span class="line">            &#125;</span><br><span class="line">            /// 设置比对锚点证书数组</span><br><span class="line">            SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);</span><br><span class="line">/// 验证证书有效性</span><br><span class="line">            if (!AFServerTrustIsValid(serverTrust)) &#123;</span><br><span class="line">                return NO;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it&apos;s the Root CA)</span><br><span class="line">            /// 验证是否证书一致，我们设置的证书数组中，包含其中一个即可。</span><br><span class="line">            NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</span><br><span class="line">            </span><br><span class="line">            for (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]) &#123;</span><br><span class="line">                if ([self.pinnedCertificates containsObject:trustChainCertificate]) &#123;</span><br><span class="line">                    return YES;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">        case AFSSLPinningModePublicKey: &#123;</span><br><span class="line">        /// 验证公钥模式，只进行证书的公钥一致性验证。</span><br><span class="line">            NSUInteger trustedPublicKeyCount = 0;</span><br><span class="line">            NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</span><br><span class="line">/// 获取证书中的公钥数组，与自己设置的证书中的公钥数组进行比对，有一个相同即可。</span><br><span class="line">            for (id trustChainPublicKey in publicKeys) &#123;</span><br><span class="line">                for (id pinnedPublicKey in self.pinnedPublicKeys) &#123;</span><br><span class="line">                    if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</span><br><span class="line">                        trustedPublicKeyCount += 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return trustedPublicKeyCount &gt; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们使用 AF 进行 https 请求时。</p><ol><li><p>假如我们想无条件的信任服务器的证书，就将 <code>manager.securityPolicy.SSLPinningMode = AFSSLPinningModeNone</code>，<code>manager.securityPolicy.allowInvalidCertificates = NO</code> ，这样服务端要求进行 服务端证书认证 时，是直接信任的。<br>直接信任服务端的证书，会有 中间人攻击 的隐患，我们使用 Charles 进行 HTTPS 抓包时，对于 客户端 ，Charles 是服务端，对于 服务端，Charles 是客户端，客户端收到的 证书认证中，证书 是 Charles 的证书，系统会通过认证。  </p></li><li><p>假如我们需要验证服务端证书，就在开发期间导入 证书，可以选择证书验证模式或者 公钥验证模式，AF 自动去帮我们验证证书或者公钥一致性。</p></li></ol><h3 id="双向认证-1"><a href="#双向认证-1" class="headerlink" title="双向认证"></a>双向认证</h3><p>AF 中，似乎只默认处理了单向认证也就是针对于 服务端的认证需求，但是也允许我们自己处理认证需求，通过设置 <code>manager.sessionDidReceiveAuthenticationChallenge</code> ，具体代码如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">/// 设置 manager 的 认证需求处理 block</span><br><span class="line">    @weakify(manager);</span><br><span class="line">    @weakify(self);</span><br><span class="line">    [manager setSessionDidReceiveAuthenticationChallengeBlock:^NSURLSessionAuthChallengeDisposition(NSURLSession * _Nonnull session, NSURLAuthenticationChallenge * _Nonnull challenge, NSURLCredential *__autoreleasing  _Nullable * _Nullable credential) &#123;</span><br><span class="line">        NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">            /// 针对于服务端 证书验证，还是走 AF 的配置进行处理。</span><br><span class="line">            if ([manager_weak_.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                *credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">                if (credential) &#123;</span><br><span class="line">                    disposition = NSURLSessionAuthChallengeUseCredential;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodClientCertificate])</span><br><span class="line">        &#123;</span><br><span class="line">        /// 针对于客户端的认证需求，通过事先导入的 p12 文件生成证书，传给系统。</span><br><span class="line">            SecIdentityRef identity = NULL;</span><br><span class="line">            SecTrustRef trust = NULL;</span><br><span class="line">            NSString *p12 = [[NSBundle mainBundle] pathForResource:@&quot;client&quot;ofType:@&quot;p12&quot;];</span><br><span class="line">            NSFileManager *fileManager =[NSFileManager defaultManager];</span><br><span class="line">            </span><br><span class="line">            if(![fileManager fileExistsAtPath:p12])</span><br><span class="line">            &#123;</span><br><span class="line">                NSLog(@&quot;client.p12:not exist&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                NSData *PKCS12Data = [NSData dataWithContentsOfFile:p12];</span><br><span class="line">                </span><br><span class="line">                if ([[self_weak_ class] extractIdentity:&amp;identity andTrust:&amp;trust fromPKCS12Data:PKCS12Data])</span><br><span class="line">                &#123;</span><br><span class="line">                    SecCertificateRef certificate = NULL;</span><br><span class="line">                    SecIdentityCopyCertificate(identity, &amp;certificate);</span><br><span class="line">                    const void*certs[] = &#123;certificate&#125;;</span><br><span class="line">                    CFArrayRef certArray =CFArrayCreate(kCFAllocatorDefault, certs,1,NULL);</span><br><span class="line">                    *credential =[NSURLCredential credentialWithIdentity:identity certificates:(__bridge  NSArray*)certArray persistence:NSURLCredentialPersistencePermanent];</span><br><span class="line">                    disposition =NSURLSessionAuthChallengeUseCredential;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">        &#125;</span><br><span class="line">        return disposition;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">/// 根据 NSData 生成证书的方法</span><br><span class="line">+ (BOOL)extractIdentity:(SecIdentityRef*)outIdentity andTrust:(SecTrustRef *)outTrust fromPKCS12Data:(NSData *)inPKCS12Data &#123;</span><br><span class="line">    OSStatus securityError = errSecSuccess;</span><br><span class="line">    //client certificate password</span><br><span class="line">    NSDictionary*optionsDictionary = [NSDictionary dictionaryWithObject:@&quot;your p12 file pwd&quot;</span><br><span class="line">                                                                 forKey:(__bridge id)kSecImportExportPassphrase];</span><br><span class="line">    </span><br><span class="line">    CFArrayRef items = CFArrayCreate(NULL, 0, 0, NULL);</span><br><span class="line">    securityError = SecPKCS12Import((__bridge CFDataRef)inPKCS12Data,(__bridge CFDictionaryRef)optionsDictionary,&amp;items);</span><br><span class="line">    </span><br><span class="line">    if(securityError == 0) &#123;</span><br><span class="line">        CFDictionaryRef myIdentityAndTrust =CFArrayGetValueAtIndex(items,0);</span><br><span class="line">        const void*tempIdentity =NULL;</span><br><span class="line">        tempIdentity= CFDictionaryGetValue (myIdentityAndTrust,kSecImportItemIdentity);</span><br><span class="line">        *outIdentity = (SecIdentityRef)tempIdentity;</span><br><span class="line">        const void*tempTrust =NULL;</span><br><span class="line">        tempTrust = CFDictionaryGetValue(myIdentityAndTrust,kSecImportItemTrust);</span><br><span class="line">        *outTrust = (SecTrustRef)tempTrust;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;Failedwith error code %d&quot;,(int)securityError);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双向认证中，我们依然要对服务端证书进行认证，以及对其他的 认证需求类型，指定进行系统默认的处理；但是主要的是针对客户端认证代码，利用我们实现导入的证书文件，生成了一个证书交给了系统，让系统为我们进行进一步的处理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apple 文档 Authentication and Credentials 的翻译</title>
      <link href="/2018/12/04/Apple-%E6%96%87%E6%A1%A3Authentication-and-Credentials-%E7%BF%BB%E8%AF%91/"/>
      <url>/2018/12/04/Apple-%E6%96%87%E6%A1%A3Authentication-and-Credentials-%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p>对 Apple 的 认证和证书 开发文档的一个翻译 <a id="more"></a></p><h2 id="Handling-an-Authentication-Challenge"><a href="#Handling-an-Authentication-Challenge" class="headerlink" title="Handling an Authentication Challenge"></a>Handling an Authentication Challenge</h2><p><strong>Respond appropriately when a server demands authentication for a URL request.</strong>  </p><p><em>当服务器要求认证时，需要适当的进行处理。</em></p><hr><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><strong>When your app makes a request with a NSURLSession Task,the server may respond with one or more demands for credentials before continuing. The session task attempts to handle this for you. IF it can’t ,it calls your session’s delegate to handle the challenges.</strong><br>当我们的 app 用 NSURLSession Task 发起一次请求之前，服务器可能返回需要认证的response，session task 会自动对其进行处理，假如处理不了，会回调NSURLSession 的 delegate ，让 delegate 进行处理。</p><p><strong>Implement the delegate methods described in this article to answer challengs issues by a server that your app connects to. If you don’t implement a delegate, your request may be denied by the server, and you receive a response with HTTP status code 401(Forbidden)  instead of the data you expect.</strong><br>为了响应服务器对认证的需求，你必须在 app 中实现本文中提到的代理方法，否则请求将会被服务器拒绝，从而收到 401 错误。  </p><h3 id="Determine-the-Appropriate-Delegate-Method"><a href="#Determine-the-Appropriate-Delegate-Method" class="headerlink" title="Determine the Appropriate Delegate Method"></a>Determine the Appropriate Delegate Method</h3><p>在代理方法进行合适的处理。  </p><p><strong>Implement one or both delegate authentication methods,depending on the nature of the challenge(s) you receive.</strong><br>根据你的需求，实现其中以下一个或多个方法。  </p><ul><li><p><strong>Implement the <code>URLSession:didReceiveChallenge:completionHandler:</code>method of <code>NSURLSessionDelegate</code>to handle session-wide challenges. These ars challengs like Transport Layer Security(TLS) validation. Once you’ve successfully handled this kind of challenge, your action remains in effect for all tasks created from that NSURLSession.</strong> </p><p>  处理 session 范围的认证需求，例如 TLS 认证，你需要实现<code>NSURLSessionDelegate</code> 代理中的<code>URLSession:didReceiveChallenge:completionHandler:</code>方法。一旦你实现了这个方法成功处理了这类认证需求，所有 <code>NSURLSession</code> 生成的 <code>task</code>都会应用这个方法进行处理。</p></li><li><p><strong>Implement the  <code>URLSession:task:didReceiveChallenge:completionHandler:</code>method of <code>NSURLSessionTaskDelegate</code> to handle task-specific challenges. These are challenges like demands for username/password authentication. Each task created from a given session may issue its own challenges.</strong></p><p>  为了处理指定<code>task</code>的认证需求，你需要实现 <code>NSURLSessionTaskDelegate</code>中的<code>URLSession:task:didReceiveChallenge:completionHandler:</code>方法，这有点类似于关于 用户名/密码 的认证，每个<code>task</code>可能会有自己的认证需求。</p></li></ul><p><strong>AS a simple example, consider what happens when you request an http URL protected by HTTP Basic authentication, as defined in RFC 7617. Because this is a task-specific challenge, you handle this by implementing <code>URLSession:task:didReceiveChallenge:completionHandler:</code></strong><br>举个简单的例子，当你发起一个需要进行 HTTP Basic authentication 的请求时，因为这属于一个 <code>task</code> 层面的认证需求，你需要实现<code>URLSession:task:didReceiveChallenge:completionHandler:</code> 方法。  </p><blockquote><p><strong>Note</strong>  </p></blockquote><p><strong>If you connect via https, you also receive a server trust challenge. See performing Manual Server Trust Authentication for information on handling this type of session-wide challenge.</strong></p><blockquote><p>如果你通过 https 进行网络连接，你也会收到认证回调，查看 Performing Manual Server Trust Authentication 文档对这一 session 级别的认证 进行详细了解</p></blockquote><h3 id="Determine-the-Type-of-Authentication-Challenge"><a href="#Determine-the-Type-of-Authentication-Challenge" class="headerlink" title="Determine the Type of Authentication Challenge"></a>Determine the Type of Authentication Challenge</h3><p>决定认证挑战的类型 </p><p><strong>When you receive an authentication challenge, use your delegate method to determine the type of challenge. The delegate method receives a <code>NSURLAuthentication Challenge</code> instance that describes the challenge being issued. This instance contains a <code>protectionSpace</code> property whose <code>authenticationMethod</code> property indicates the kind of challenge being issued (such as a request for a username and password, or a client certificate). You use this value to determine whether you can handle the challenge.</strong><br>当你收到一个认证需求时，根据回调方法，可以获取到认证的类型。代理方法会返回一个 <code>NSURLAuthentication Challenge</code> 对象，描述了这个认证需求。这个对象包含了一个 <code>protectionSpace</code> 属性，这个属性中又包含有一个<code>authenticationMethod</code>属性，表明了这个需求的类型(比如用户名/密码，或者客户端证书)。你可以根据这个类型来判断是否回应这个认证需求。</p><p><strong>You respond to the challenge by directly invoking the completion handler passed in to the challenge, passing an <code>NSURLSessionAuthChallengeDisposition</code> indicating your response to the challenge. You use the disposition argument to provide a credential, cancel the request, or allow the default handling to proceed, whichever is appropriate.</strong><br>通过调用方法回调的 completion block，可以对这次认证需求做出响应。在 completion block 中，传入不同的<code>NSURLSessionAuthChallengeDisposition</code>参数，代表了不同含义，例如提供一个证书、取消这次请求或者进行默认操作，这取决于你。  </p><p><strong>Listing1 tests the authentication method to see if it is the expected type, HTTP Basic. If the authenticationMethod property indicates some other kind of challenge, it calls the completion handler with the <code>NSURLSessionAuthChallengePerformDefaultHandling</code> disposition. Telling the task to use its default handling may satisfy the challenge; otherwise, the task will move on to the next challenge in the response and call this delegate again. This process continues until the task reaches the HTTP Basic challenge that you expect to handle.</strong><br>下面的例1中，判断了这次认证需求的类型是否是 HTTP Basic，假如是其他的类型，使用默认的<code>NSURLSessionAuthChallengePerformDefaultHandling</code>进行处理，task 会遍历所有的认证需求，不断的回调该方法，直到类型是 HTTP Basic 的时候才会进行下一步处理</p><p><strong>Listing 1<br>Checking the authentication method of an authentication challenge</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let authMethod = challenge.protectionSpace.authenticationMethod</span><br><span class="line">guard authMethod == NSURLAuthenticationMethodHTTPBasic else &#123;</span><br><span class="line">    completionHandler(.performDefaultHandling, nil)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Create-a-Credential-Instance"><a href="#Create-a-Credential-Instance" class="headerlink" title="Create a Credential Instance"></a>Create a Credential Instance</h3><p><strong>To successfully answer the challenge, you need to submit a credential appropriate to type of challenge you have received.  For HTTP Basic and HTTP Digest challenges, you provide a username and password. Listing 2 shows a helper method that attempts to create a <code>NSURLCredential</code> instance from user-interface fields, if they are filled in.</strong><br>为了成功的响应认证需求，你需要提交一个适合这次需求类型的证书。对于 HTTP Basic 和 HTTP Digest 认证需求来说，你需要提供一个 用户名和 密码。例2 展示了一个从用户界面的数据生成一个证书的例子。  </p><p>*<em>Listing 2<br>Creating a URLCredential from user interface values<br>*</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func credentialsFromUI() -&gt; URLCredential? &#123;</span><br><span class="line">    guard let username = usernameField.text, !username.isEmpty,</span><br><span class="line">        let password = passwordField.text, !password.isEmpty else &#123;</span><br><span class="line">            return nil</span><br><span class="line">    &#125;</span><br><span class="line">    return URLCredential(user: username, password: password,</span><br><span class="line">                         persistence: .forSession)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>In this example, the returned NSURLCredential has NSURLCredentialPersistenceForSession persistence, so it’s only stored by the NSURLSession instance that created the task. You would need to supply new NSURLCredential instances for tasks created by other session instances, and on future runs of the app.</strong><br>在这个例子中，这个证书的生命周期是<code>NSURLCredentialPersistenceForSession</code>，这代表了该证书只会作用于生成这个 task 的 session 中，对于其他 session 发起的 task ，你需要生成一个新的证书来应对。  </p><h3 id="Call-the-Completion-Handler"><a href="#Call-the-Completion-Handler" class="headerlink" title="Call the Completion Handler"></a>Call the Completion Handler</h3><p><strong>Once you’ve tried to create a credential instance, you must call the completion handler to answer the challenge.</strong><br>生成证书后，必须回调 completion block ，来响应这次 认证需求</p><ul><li><p>If you can’t create a credential, or if the user explicitly canceled, call the completion handler and pass the <code>NSURLSessionAuthChallengeCancelAuthenticationChallenge</code> disposition.<br>  假如无法生成证书，或者用户明确的手动取消了，你可以在 block 中传入<code>NSURLSessionAuthChallengeCancelAuthenticationChallenge</code>参数。  </p></li><li><p>If you can create a credential instance, use the  <code>NSURLSessionAuthChallengeUseCredential</code>disposition to pass it to the completion handler.<br>假如可以生成证书，completion block 中传入 <code>NSURLSessionAuthChallengeUseCredential</code>参数</p></li></ul><p><strong>Listing 3 shows both these options.</strong><br>例三处理了这两种情况</p><p><strong>Listing 3<br>Invoking the authentication challenge completion Handler</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">guard let credential = credentialOrNil else &#123;</span><br><span class="line">    completionHandler(.cancelAuthenticationChallenge, nil)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">completionHandler(.useCredential, credential)</span><br></pre></td></tr></table></figure><p><strong>If you supply a credential that is accepted by the server, the task begins uploading or downloading data.</strong><br>假如你传入的证书被服务器接受了，请求会继续进行。</p><blockquote><p><strong>Important</strong></p></blockquote><p><strong>You can pass the completion handler to other methods or temporarily store it in a property, for situations like waiting for the user to complete a username/password dialog. But eventually you must call the completion handler to complete the challenge and allow the task to proceed, even if you’re choosing to cancel, as seen in the failure case of Listing 3.</strong></p><blockquote><p>在必要的时候，你可以将 completion block 传到其他方法中，甚至可以存储起来，比如等待用户填写用户名和密码的时候；但是为了让请求继续进行，你必须回调这个 completion block ，即使你选择取消这次请求的时候，你也需要像上面 例3 中那样进行处理。</p></blockquote><h3 id="Handle-Failues-Gracefully"><a href="#Handle-Failues-Gracefully" class="headerlink" title="Handle Failues Gracefully"></a>Handle Failues Gracefully</h3><p><strong>If the credential is refused, the system calls your delegate method again. When this happens, the callback provides your rejected credential as the <code>proposedCredential</code> property of the <code>NSURLAuthenticationChallenge</code> parameter. The challenge instance also includes a <code>previousFailureCount</code> property, which indicates how many times the credential has been rejected. You can use these properties to determine what to do next. For example, if the <code>previousFailureCount</code> is greater than zero, you could use the user string of the <code>proposedCredential</code> to populate a user/password reentry UI.</strong><br>假如证书被服务器拒绝，系统会再次回调代理方法，并且将上次的证书作为 challenge 的 proposedCredential 参数返回。challenge 还有一个 previousFailureCount 的属性，代表了已经失败了多少次，你可以使用这些参数来决定下一步怎么做，例如，假如失败次数超过一次，你可以在 UI 上展示一个失败重新输入的提示。  </p><h3 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h3><p><strong>Creating URL Credentials</strong><br><strong>Performing Manual Server Trust Authentication</strong></p><h2 id="Performing-Manual-Server-Trust-Authentication"><a href="#Performing-Manual-Server-Trust-Authentication" class="headerlink" title="Performing Manual Server Trust Authentication"></a>Performing Manual Server Trust Authentication</h2><p><strong>Evaluate the server’s security credentials in your app.</strong>  </p><p>在你的 app 中认证系统的安全证书。  </p><hr><h3 id="Overview-1"><a href="#Overview-1" class="headerlink" title="Overview"></a>Overview</h3><p><strong>When you use a secure connection (such as https) with a URL request, your <code>NSURLSessionDelegate</code> receives an authentication challenge with an authentication type of <code>NSURLAuthenticationMethodServerTrust</code>. Unlike other challenges where the server is asking your app to authenticate itself, this is an opportunity for you to authenticate the server’s credentials.</strong><br>当你使用安全连接(例如 https)进行请求时，你设置的 <code>NSURLSessionDelegate</code>会被回调，并传回一个认证需求类型为<code>NSURLAuthenticationMethodServerTrest</code>的 chanllenge。其他的认证需求，服务器会要求你的 app 认证自身，这个认证需求，可以让你对服务器进行认证的。</p><blockquote><p><strong>Tip</strong><br><strong>See Handling an Authentication Challenge for an introduction to authentication challenges.</strong></p></blockquote><h3 id="Determine-When-Manual-Server-Trust-Evaluation-Is-Appropriate"><a href="#Determine-When-Manual-Server-Trust-Evaluation-Is-Appropriate" class="headerlink" title="Determine When Manual Server Trust Evaluation Is Appropriate"></a>Determine When Manual Server Trust Evaluation Is Appropriate</h3><p>何时对 Server Trust 进行手动处理     </p><p><strong>In most cases, you should let the URL Loading System’s default handling evaluate the server trust. You get this behavior when you either don’t have a delegate or don’t handle authentication challenges. However, performing your own evaluation may be useful for scenarios like the following:</strong><br>大多数情况下，你不需要实现代理方法，系统会进行默认的处理，但是在下面这些场景下，最好进行自定义的认证处理：</p><ul><li><p><strong>You want to accept server credentials that would otherwise be rejected by the system. For example, your app makes a secure connection to a development server that uses a self-signed certificate, which would ordinarily not match anything in the system’s trust store.</strong><br>有时候你必须接受系统证书，否则连接会失败。例如，你连接的服务器，使用的证书是自签的，通常情况下，这个服务器证书是没有预存到系统的新人列表中的，必须选择信任，否则连接会失败。</p></li><li><p><strong>You want to reject credentials that would otherwise be accepted by the system. For example, you want to “pin” your app to a set of specific keys or certificates under your control, rather than accept any valid credential.</strong><br>你希望你的 app 只访问某些拥有特定的证书的服务器，其他的请求一概拒绝。  </p></li></ul><p><strong>Figure 1 illustrates how an app performs manual credential evaluation by providing a delegate method to handle the authentication challenge. This bypasses the default handling. Instead, the delegate directly compares the server certificate or its public key against a copy of the certificate or key (or a hash of either of these) stored in the app bundle itself. If the delegate decides the server credential is valid, it accepts the server trust and allows the connection to continue.</strong><br>图1 表示一个 app 进行认证需求的流程，系统通过回调代理方法，将 Server Trust 的公钥和证书交给代理，代理方法中，将公钥或者证书，跟存储在 app boundle 中的公钥和证书(或者 hash 表或者其他)进行对比，假如是一致的，那么代理方法通过回调 block ，同意接受服务器证书，然后继续请求。</p><blockquote><p><strong>Note</strong><br><strong><code>NSURLSession</code> enforces <code>App Transport Security (ATS)</code>, if it is enabled for the domain you are connecting to. This applies security requirements for the certificates, TLS version, and cipher used by the connection. You cannot loosen server trust requirements for an ATS-protected domain, but you can tighten them, using the manual evaluation technique shown in this article. See <code>NSAppTransportSecurity</code> in <code>Information Property List Key Reference</code> for further details.</strong> </p><p><strong>NSURLSession 会使用 ATS 中的设置，这表明对于一个连接请求，它的 证书、TLS 版本和加密算法都是有要求的，虽然你无法避过 server trust 的认证需求，但是你可以单独的处理这些其他要求，阅读文档 Information Property List Key Reference 中的NSAppTransportSecurity 章节，获取更详细的信息。</strong></p></blockquote><h3 id="Handle-Server-Trust-Authentication-Challenges"><a href="#Handle-Server-Trust-Authentication-Challenges" class="headerlink" title="Handle Server Trust Authentication Challenges"></a>Handle Server Trust Authentication Challenges</h3><p>怎样对 server trust 认证需求进行具体处理。</p><p><strong>To perform manual server trust authentication, implement the NSURLSessionDelegate method <code>URLSession:didReceiveChallenge:completionHandler:</code>. When this method is called, the first things your implementation needs to do are to check that:</strong><br>为了手动处理 server trust 认证需求，你需要实现协议<code>NSURLSessionDelegate</code>中的<code>URLSession:didReceiveChallenge:completionHandler:</code>方法。当这个方法被回调的时候，你需要做以下检查：</p><ul><li><strong>The challenge type is server trust, and not some other kind of challenge.</strong><br>这个认证需求的类型是 server trust，而不是其他类型  </li><li><strong>The challenge’s host name matches the host that you want to perform manual credential evaluation for.</strong><br>这个认证需求发起的 host name ，与你想要请求的网站一致。</li></ul><p><strong>Listing 1 shows how to test these conditions, given the <code>challenge</code> parameter passed to the <code>URLSession:didReceiveChallenge:completionHandler:</code> callback. It gets the challenge’s <code>protectionSpace</code> and uses it to perform the two checks listed above. First, it gets the <code>authenticationMethod</code> from the protection space and checks that the type of authentication is <code>NSURLAuthenticationMethodServerTrust</code>. Then it makes sure the protection space’s <code>host</code> matches the expected name <code>example.com</code>. If either of these conditions are not met, it calls the <code>completionHandler</code> with the <code>NSURLSessionAuthChallengePerformDefaultHandling</code> disposition to allow the system to handle the challenge.</strong><br>下面的代码 例1 ，展示了怎样判断上面那些条件，并进行进一步的处理。首先获取到 <code>challenge</code>的 <code>protectionSpace</code>属性，并且获取到该属性中的<code>authenticationMethod</code>属性，判断其类型是否是<code>NSURLAuthenticationMethodServerTrust</code>，然后获取其<code>host</code>属性，判断是否跟<code>example.com</code>匹配，假如这两个判断有一个不匹配，那么调用 completionHandler block 时，disposition 参数会传入<code>NSURLSessionAuthChallengePerformDefaultHandling</code>，从而使系统处理这次认证需求。</p><p><strong>Listing 1<br>Testing the challenge type and host name of a server trust authentication challenge.</strong><br>判断 challenge 的 认证类型 和 host  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let protectionSpace = challenge.protectionSpace</span><br><span class="line">guard protectionSpace.authenticationMethod ==</span><br><span class="line">    NSURLAuthenticationMethodServerTrust,</span><br><span class="line">    protectionSpace.host.contains(&quot;example.com&quot;) else &#123;</span><br><span class="line">        completionHandler(.performDefaultHandling, nil)</span><br><span class="line">        return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Evaluate-the-Credential-in-the-Challenge"><a href="#Evaluate-the-Credential-in-the-Challenge" class="headerlink" title="Evaluate the Credential in the Challenge"></a>Evaluate the Credential in the Challenge</h3><p>如何对 challenge 中的证书进行认证<br><strong>To access the server’s credential, get the <code>serverTrust</code>property (an instance of the <code>SecTrustRef</code> class) from the <code>protection space</code>. Listing 2 shows how to access the server trust and accept or reject it. The listing starts by attempting to get the <code>serverTrust</code> property from the protection space, and falls back to default handling if the property is <code>nil</code>. Next, it passes the server trust to a private helper method <code>checkValidity(of:)</code> that compares the certificate or public key in the server trust to known-good values stored in the app bundle.</strong><br>通过获取<code>protectionSpace</code>中的<code>serverTrust</code>属性，来获取到一个<code>SectrustRef</code>实例，例2 展示了怎样获取一个 server trust，并且信任还是拒绝它，首先获取到这个 serverTrust，假如为<code>nil</code>的话，回调 completionHandler,传入参数为默认。然后将 server trust 传入到一个私有方法 <code>checkValidity(of:)</code>中，将其公钥或证书 与存储在 bundle 中的公钥或证书进行对比</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">guard let serverTrust = protectionSpace.serverTrust else &#123;</span><br><span class="line">    completionHandler(.performDefaultHandling, nil)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">if checkValidity(of: serverTrust) &#123;</span><br><span class="line">    let credential = URLCredential(trust: serverTrust)</span><br><span class="line">    completionHandler(.useCredential, credential)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // Show a UI here warning the user the server credentials are</span><br><span class="line">    // invalid, and cancel the load.</span><br><span class="line">    completionHandler(.cancelAuthenticationChallenge, nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Once the code determines the validity of the server trust, it takes one of two actions:</strong><br>根据 server trust 的正确与否，将会进行合适的处理：  </p><ul><li><p><strong>If the server trust’s credential is valid, create a new <code>NSURLCredential</code> instance from the server trust. Then call the <code>completionHandler</code> with the <code>NSURLSessionAuthChallengeUseCredential</code> disposition, passing in the newly-created credential. This tells the system to accept the server’s credentials.</strong><br>假如 server trust 的证书通过了认证，那么根据 server trust 生成一个<code>NSURLCredential</code>对象，并在 completionHandler 中，disposition 参数传入<code>NSURLSessionAuthChallengeUseCredential</code>，credential 参数传入新创建的证书对象，来告诉系统，你已经信任了这个系统证书。</p></li><li><p><strong>If the challenge’s credential is invalid, call the completionHandler with the <code>NSURLSessionAuthChallengeCancelAuthenticationChallenge</code> disposition. This tells the system to reject the server’s credentials.</strong><br>假如 server trust 的证书没有通过验证，completionHandler 的 disposition 参数传入 <code>NSURLSessionAuthChallengeCancelAuthenticationChallenge</code>，证书传入 nil ，代表你拒绝了服务器的证书验证，即请求失败。</p></li></ul><blockquote><p><strong>Tip</strong> </p><p><strong>See <code>Certificate, Key, and Trust Services</code> to learn more about how to evaluate a SecTrustRef instance or access certificates or public keys from it.</strong><br>为了更详细的了解怎样对一个<code>SecTrustRef</code>进行验证，你可以阅读<code>Certificate, Key, and Trust Services</code>文档</p></blockquote><h3 id="Create-a-Long-Term-Server-Authentication-Strategy"><a href="#Create-a-Long-Term-Server-Authentication-Strategy" class="headerlink" title="Create a Long-Term Server Authentication Strategy"></a>Create a Long-Term Server Authentication Strategy</h3><p>从长远开发的角度来看，优雅的处理服务器认证需求</p><p><strong>If you determine that you need to evaluate server trust manually in some or all cases, plan for what your app will do if you need to change your server credentials. Keep the following guidelines in mind:</strong><br>在某些情况下，假如你决定手动的对认证需求进行处理，考虑一下这种情况，假如服务器的证书需要更换怎么办？你可以参考以下的方法：  </p><ul><li><p><strong>Compare the server’s credentials against a public key, instead of storing a single certificate in your app bundle. This will allow you to reissue a certificate for the same key and update the server, rather than needing to update the app.</strong><br>在进行证书比对时，将服务器证书与公钥进行比对，而不是在 app bundle 中存储一个证书，这样当服务器更换证书时，你仍然可以使用这个公钥，而不是更新你的 app。</p></li><li><p><strong>Compare the issuing certificate authority’s (CA’s) keys, rather than using the leaf key. This way, you can deploy certificates containing new keys signed by the same CA.</strong><br>比对证书时，使用根证书的 key 进行比对，而不是使用节点 key，这样你可以支持验证根证书下发的新的证书。</p></li><li><p><strong>Use a set of keys or CAs, so you can rotate server credentials more gracefully.</strong><br>采用一个证书或者公钥的集合，这样使你更优雅的处理证书的验证。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最新 SDWebImage 解读</title>
      <link href="/2018/12/04/%E6%9C%80%E6%96%B0-SDWebImage-%E8%A7%A3%E8%AF%BB/"/>
      <url>/2018/12/04/%E6%9C%80%E6%96%B0-SDWebImage-%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>针对于 SDWebImage 4.0 版本的源码分析<a id="more"></a></p><h3 id="View-层"><a href="#View-层" class="headerlink" title="View 层"></a>View 层</h3><p>负责 view 的 loading 控件管理，每个 view 的请求发起、取消入口。</p><h4 id="UIView-WebCacheOperation-分类"><a href="#UIView-WebCacheOperation-分类" class="headerlink" title="UIView+WebCacheOperation 分类"></a>UIView+WebCacheOperation 分类</h4><p>负责管理每次请求产生的 <code>SDWebImageCombinedOperation</code>，可以将这些<code>operation</code>对象存储到自己关联的<code>NSMapTable</code>中，对外提供根据<code>key</code>添加、删除、取消某个<code>operation</code>的接口。</p><h4 id="UIView-WebCache-分类"><a href="#UIView-WebCache-分类" class="headerlink" title="UIView+WebCache 分类"></a>UIView+WebCache 分类</h4><p>内部调用 <code>SDWebImageManager</code>类发起请求，请求前会调用<code>UIView+WebCacheOperation</code>中的方法，取消上次的请求，并将这次请求方法产生的 <code>SDWebImageCombinedOpreation</code> 对象存储起来、并且管理 loading 的控件。</p><h3 id="Manager-层"><a href="#Manager-层" class="headerlink" title="Manager 层"></a>Manager 层</h3><h4 id="SDWebImageManager"><a href="#SDWebImageManager" class="headerlink" title="SDWebImageManager"></a>SDWebImageManager</h4><p>负责整体请求的管理，包括缓存、请求的发起、取消。<br>内部有如下属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface SDWebImageManager ()</span><br><span class="line"></span><br><span class="line">/// cache 负责图片在缓存中的查找、将图片缓存到内存和磁盘中，压缩，解压操作。</span><br><span class="line">@property (strong, nonatomic, readwrite, nonnull) SDImageCache *imageCache;</span><br><span class="line">/// 负责图片的网络请求发起，取消等操作。</span><br><span class="line">@property (strong, nonatomic, readwrite, nonnull) SDWebImageDownloader *imageDownloader;</span><br><span class="line">/// 记录所有失败的网络请求。</span><br><span class="line">@property (strong, nonatomic, nonnull) NSMutableSet&lt;NSURL *&gt; *failedURLs;</span><br><span class="line">/// 负责多线程下的 failedUrls 的线程安全，信号量锁，值为 1</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t failedURLsLock; // a lock to keep the access to `failedURLs` thread-safe</span><br><span class="line">/// 保存每次产生的 SDWebImageCombinedOperation 对象，并管理</span><br><span class="line">@property (strong, nonatomic, nonnull) NSMutableSet&lt;SDWebImageCombinedOperation *&gt; *runningOperations;</span><br><span class="line">/// 负责多线程下的 runningOperationsLock 线程安全，信号量锁，值为 1</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t runningOperationsLock; // a lock to keep the access to `runningOperations` thread-safe</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ol><li>每次请求都先根据<code>url</code>查找是否在失败请求集合中，假如<code>url</code>为空或者 配置不是<code>SDWebImageRetryFailed</code>，且之前<code>url</code>请求失败过，那么直接返回失败。</li><li>根据<code>url</code>查找内存、硬盘，有的话直接返回图片。</li><li>发起请求，并将产生的<code>SDWebImageCombinedOpreation</code>存储到<code>runningOperations</code>中。</li></ol><h4 id="SDWebImageDownloader"><a href="#SDWebImageDownloader" class="headerlink" title="SDWebImageDownloader"></a>SDWebImageDownloader</h4><p>负责具体图片请求的发起。<br>内部属性如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@interface SDWebImageDownloader () &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate&gt;</span><br><span class="line"></span><br><span class="line">/// 是否解压下载下来的图片，默认是 YES，在子线程中解压，但是会消耗内存资源</span><br><span class="line">@property (assign, nonatomic) BOOL shouldDecompressImages;</span><br><span class="line"></span><br><span class="line">/// 可以设置下载队列的最大并发量，默认为 6</span><br><span class="line">@property (assign, nonatomic) NSInteger maxConcurrentDownloads;</span><br><span class="line"></span><br><span class="line">/// 当前下载队列中的任务数</span><br><span class="line">@property (readonly, nonatomic) NSUInteger currentDownloadCount;</span><br><span class="line"></span><br><span class="line">/// 下载超时时间，默认是 15 秒</span><br><span class="line">@property (assign, nonatomic) NSTimeInterval downloadTimeout;</span><br><span class="line"></span><br><span class="line"> /// 内部 NSURLSession 初始化使用到的 configuration</span><br><span class="line">@property (readonly, nonatomic, nonnull) NSURLSessionConfiguration *sessionConfiguration;</span><br><span class="line"></span><br><span class="line"> /// 下载任务的执行顺序，有先进先出，后进先出，默认先进先出，按添加顺序执行。</span><br><span class="line">@property (assign, nonatomic) SDWebImageDownloaderExecutionOrder executionOrder;</span><br><span class="line"></span><br><span class="line">/// 下载队列，默认最大并发量为 6</span><br><span class="line">@property (strong, nonatomic, nonnull) NSOperationQueue *downloadQueue;</span><br><span class="line"></span><br><span class="line">/// 上次发起的 operation ，当 executionOrder 为 后进先出时，会用到，上次 operation 的 dependency 为当前 operation</span><br><span class="line">@property (weak, nonatomic, nullable) NSOperation *lastAddedOperation;</span><br><span class="line"></span><br><span class="line">/// 每次请求根据该属性生成一个 NSOperation 对象，默认为 [SDWebImageDownloaderOperation class]。</span><br><span class="line">@property (assign, nonatomic, nullable) Class operationClass;</span><br><span class="line"></span><br><span class="line">/// 保存每次产生的 SDWebImageDownloaderOperation 对象，url 作为 key，也就是每个 url 只产生一个 SDWebImageDownloaderOperation 对象</span><br><span class="line">@property (strong, nonatomic, nonnull) NSMutableDictionary&lt;NSURL *, SDWebImageDownloaderOperation *&gt; *URLOperations;</span><br><span class="line"></span><br><span class="line">/// 存储请求头，有默认值，每次发起 request 用该字典初始化请求头</span><br><span class="line">@property (strong, nonatomic, nullable) SDHTTPHeadersMutableDictionary *HTTPHeaders;</span><br><span class="line"></span><br><span class="line">/// 信号量锁，值为 1，保证 URLOperations 多线程安全</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t operationsLock; // a lock to keep the access to `URLOperations` thread-safe</span><br><span class="line"></span><br><span class="line">/// 请求头锁，值为 1，保证 HTTPHeaders 多线程安全</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t headersLock; // a lock to keep the access to `HTTPHeaders` thread-safe</span><br><span class="line"></span><br><span class="line">/// 每次发起请求使用的 session ，delegate 为 self ，delegateQueue 为 nil，保证每个请求的回调会串行回调的。</span><br><span class="line">@property (strong, nonatomic) NSURLSession *session;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>每次请求，都检查 <code>URLOperations</code>字典中是否有这个<code>url</code>对应的<code>operation</code>，有的话返回，没有的话生成一个新的<code>SDWebImageDownloaderOperation</code>对象并加入到下载队列<code>downloadQueue</code>中去发起请求，并且存储到<code>URLOperations</code>中。<br>这样，针对同一<code>url</code>的多次请求，只会生成一个<code>operation</code>对象，去下载，每次请求都会生成一个<code>SDWebImageDownloadToken</code>对象，保存有这次请求的回调<code>block</code>。  </p><h4 id="SDImageCache"><a href="#SDImageCache" class="headerlink" title="SDImageCache"></a>SDImageCache</h4><p>针对于图片的内存、硬盘缓存、并进行压缩、解压缩操作。<br>相关属性如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@interface SDImageCache ()</span><br><span class="line"></span><br><span class="line">#pragma mark - Properties</span><br><span class="line">/// 针对于内存的 缓存管理，继承自 NSCache，但是内部有个 NSMapTable 进行存储，url 作为 key，image 作为 value，其中 value 配置属性 为 weak，对内存不足进行了监听，会清除所有内存缓存。</span><br><span class="line">@property (strong, nonatomic, nonnull) SDMemoryCache *memCache;</span><br><span class="line"></span><br><span class="line">/// 硬盘存储路径，默认为 NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) 路径</span><br><span class="line">@property (strong, nonatomic, nonnull) NSString *diskCachePath;</span><br><span class="line"></span><br><span class="line">/// 允许我们进行预缓存图片，并存储到这个路径数组中，之后加载图片时会查找这些路径。</span><br><span class="line">@property (strong, nonatomic, nullable) NSMutableArray&lt;NSString *&gt; *customPaths;</span><br><span class="line"></span><br><span class="line">/// 图片读取队列，串行队列</span><br><span class="line">@property (strong, nonatomic, nullable) dispatch_queue_t ioQueue;</span><br><span class="line"></span><br><span class="line">/// 文件管理 manager</span><br><span class="line">@property (strong, nonatomic, nonnull) NSFileManager *fileManager;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>这个类支持对图片进行存储，查找，压缩，解压缩，其中压缩解压缩操作使用了<code>CoreGraphics</code>库中的方法。</p><h3 id="Operation-层"><a href="#Operation-层" class="headerlink" title="Operation 层"></a>Operation 层</h3><h4 id="SDWebImageCombinedOpreation"><a href="#SDWebImageCombinedOpreation" class="headerlink" title="SDWebImageCombinedOpreation"></a>SDWebImageCombinedOpreation</h4><p>该对象继承自 NSObject ，只要是对某一图片请求进行取消操作，包括缓存和网络请求，属性和取消方法如下：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@interface SDWebImageCombinedOperation : NSObject &lt;SDWebImageOperation&gt;</span><br><span class="line">/// 是否被取消</span><br><span class="line">@property (assign, nonatomic, getter = isCancelled) BOOL cancelled;</span><br><span class="line"></span><br><span class="line">/// 针对下请求管理</span><br><span class="line">@property (strong, nonatomic, nullable) SDWebImageDownloadToken *downloadToken;</span><br><span class="line"></span><br><span class="line">/// 针对缓存管理</span><br><span class="line">@property (strong, nonatomic, nullable) NSOperation *cacheOperation;</span><br><span class="line"></span><br><span class="line">/// 保存 downloadManager，引用其 downloader</span><br><span class="line">@property (weak, nonatomic, nullable) SDWebImageManager *manager;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SDWebImageCombinedOperation</span><br><span class="line"></span><br><span class="line">- (void)cancel &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        self.cancelled = YES;</span><br><span class="line">        if (self.cacheOperation) &#123;</span><br><span class="line">            [self.cacheOperation cancel];</span><br><span class="line">            self.cacheOperation = nil;</span><br><span class="line">        &#125;</span><br><span class="line">        if (self.downloadToken) &#123;</span><br><span class="line">            [self.manager.imageDownloader cancel:self.downloadToken];</span><br><span class="line">        &#125;</span><br><span class="line">        [self.manager safelyRemoveOperationFromRunning:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，类中存储了<code>downloadToken</code>和<code>cacheOperation</code>对象，还有个<code>SDWebImageManager</code>对象，当进行取消操作时，分别对缓存和网络请求进行取消操作，并且将该对象从<code>SDWebImageManager</code>的<code>runningOperations</code>集合中移除。  </p><h4 id="SDWebImageDownloaderOperation"><a href="#SDWebImageDownloaderOperation" class="headerlink" title="SDWebImageDownloaderOperation"></a>SDWebImageDownloaderOperation</h4><p>继承自<code>NSOperation</code>,主要负责某次网络请求的发起和取消等管理。内部属性如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@interface SDWebImageDownloaderOperation ()</span><br><span class="line"></span><br><span class="line">/// 存储着对同一 url 发起的多次请求时，所有的回调 block，里面是多个字典，每个字典有 progressBlock 和 completionBlock</span><br><span class="line">@property (strong, nonatomic, nonnull) NSMutableArray&lt;SDCallbacksDictionary *&gt; *callbackBlocks;</span><br><span class="line"></span><br><span class="line">/// 是否在执行</span><br><span class="line">@property (assign, nonatomic, getter = isExecuting) BOOL executing;</span><br><span class="line"></span><br><span class="line">/// 是否已结束</span><br><span class="line">@property (assign, nonatomic, getter = isFinished) BOOL finished;</span><br><span class="line"></span><br><span class="line">/// 存储网络返回的数据，每次网络回调时都拼接到该属性上</span><br><span class="line">@property (strong, nonatomic, nullable) NSMutableData *imageData;</span><br><span class="line"></span><br><span class="line">/// NSURLCache 中缓存的数据</span><br><span class="line">@property (copy, nonatomic, nullable) NSData *cachedData; // for `SDWebImageDownloaderIgnoreCachedResponse`</span><br><span class="line"></span><br><span class="line">/// 发起请求的默认 session ，由 SDImageDownloader 持有</span><br><span class="line">@property (weak, nonatomic, nullable) NSURLSession *unownedSession;</span><br><span class="line"></span><br><span class="line">/// 自定义 session 时，该 session 需要使用者手动创建</span><br><span class="line">@property (strong, nonatomic, nullable) NSURLSession *ownedSession;</span><br><span class="line"></span><br><span class="line">/// 网络请求对应的 dataTask，每个 url 最多对应一个 dataTask 对象。</span><br><span class="line">@property (strong, nonatomic, readwrite, nullable) NSURLSessionTask *dataTask;</span><br><span class="line"></span><br><span class="line">/// 保证 callbackBlocks 多线程安全的信号量锁</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t callbacksLock; // a lock to keep the access to `callbackBlocks` thread-safe</span><br><span class="line"></span><br><span class="line">/// 压缩和解压缩时的串行队列</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_queue_t coderQueue; // the queue to do image decoding</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">/// 后台下载的 identifier</span><br><span class="line">@property (assign, nonatomic) UIBackgroundTaskIdentifier backgroundTaskId;</span><br><span class="line">#endif</span><br><span class="line">/// 解压工具</span><br><span class="line">@property (strong, nonatomic, nullable) id&lt;SDWebImageProgressiveCoder&gt; progressiveCoder;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>针对于每次发起的图片网络请求，每个 url 都对应生成一个<code>SDWebImageDownloaderOperation</code>对象，这个类继承自<code>NSOperation</code>类，重写了<code>start</code>方法，通过外界传入的<code>request</code>和<code>session</code>，生成一个<code>NSURLSessionTask</code>对象，进行网络请求，同时，每个对象都有一个<code>callbackBlocks</code>数组，存储着对同一 url 请求的多个监听 block ，<em>每次对同一 url 进行请求，都会将 progressBlock 和 completedBlock 存储到一个字典中，再将字典加入到 callbackBlocks 数组中，请求回调时，SDImageDownloader 会根据 dataTask 的标识，调用相应的 DownloaderOperation 的回调方法，方法中，依次遍历数组中所有的 block 执行。</em></p><h4 id="SDWebImageDownloadToken"><a href="#SDWebImageDownloadToken" class="headerlink" title="SDWebImageDownloadToken"></a>SDWebImageDownloadToken</h4><p>属性如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/// 发起请求时的 图片 url ，标识每次请求</span><br><span class="line">@property (nonatomic, strong, nullable) NSURL *url;</span><br><span class="line"></span><br><span class="line">/// 字典类型，存储每次请求的回调 block</span><br><span class="line">@property (nonatomic, strong, nullable) id downloadOperationCancelToken;</span><br><span class="line"></span><br><span class="line">/// 网络请求</span><br><span class="line">@property (nonatomic, weak, nullable) NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *downloadOperation;</span><br></pre></td></tr></table></figure><p>每次发起请求时创建一个 downloadToken 对象，保存有 url、回调 block 和 downloadOperation ，但是其实 downloadOperation 是没有直接用到的，实际查找的时候是根据 url 查找到的，不知道为什么非要保持有一个 downloadOperation 的引用呢？这是我没搞清楚的地方。<br>为了更清楚的理解，我画了一张 SDWebImage 的 <a href="https://github.com/eassy/LibraryImgs/blob/master/SDWebImage_UML/SDImage%20UML.jpg" target="_blank" rel="noopener">UML</a> 类图，简单的指出了每个类的关系。</p><h2 id="hash-表"><a href="#hash-表" class="headerlink" title="hash 表"></a>hash 表</h2><p>hash 表组成由 一个数组 T，加上一个 hash 函数，这个 函数 将 key 映射成一个索引，表明值就存储到 T 的这个索引的位置上，一般来说，这个函数内部生成一个值 p，将 p 对 T 的长度 m 取余，得到索引值，从而保证了索引值在 0-m 之间。<br>最好的 hash 函数，保证得到的这个索引，尽可能的平均，但是也会发生冲突，比如两个不同的 key1，key2，得到的索引值是相同的，这时候要解决冲突：</p><ol><li>拉链法 发生冲突时，索引位置指向了一个链表，节点是键值，该链表依次向后排列，这样查找时，根据链表依次查找 与 key 相同的 节点。  </li><li>开放寻址法 存储的时候根据一定的规则去找值为空的索引，最简单的是线性探测法，直接找到下一个位置判断是否为空，一直找到一个为空的索引位置。查找的时候，也是按照这个规则，一直查找到与 key 相同的索引，取出值。</li></ol><h2 id="NSDictionary-的底层实现"><a href="#NSDictionary-的底层实现" class="headerlink" title="NSDictionary 的底层实现"></a>NSDictionary 的底层实现</h2><p>NSDictionary 内部其实是用 NSMapTable 实现的，NSMapTable 结构体包括一系列的函数指针，比如 hash ，判断 key 是否相同，还包括一个链表指针，至于这个链表指针做什么用的，可能跟拉链法中处理冲突时相关。  </p><h2 id="NSMapTable"><a href="#NSMapTable" class="headerlink" title="NSMapTable"></a>NSMapTable</h2><p>区别于 NSDictionary 的 key ，只能用 OC 对象(其实实现了 hash 和 isEqual 的其他对象也可以)，必须支持<code>NSCopying</code>协议，并且会对 key 进行 <code>copy</code> 操作，对 value 进行 <code>retain</code>操作，而 NSMapTable 可以允许设置 key 和 value 的操作类型，copy 还是 strong，还是 weak。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RunLoop-CommonModes</title>
      <link href="/2018/11/20/RunLoop-CommonModes/"/>
      <url>/2018/11/20/RunLoop-CommonModes/</url>
      
        <content type="html"><![CDATA[<p>RunLoop 的 CommonModes ，其实不是一个真正的 modes，而是一个伪 mode.. <a id="more"></a>，每个 _CFRunLoopRef 的数据结构大致是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> struct __CFRunLoop &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;/* locked for accessing mode list */</span><br><span class="line">    __CFPort _wakeUpPort;// used for CFRunLoopWakeUp </span><br><span class="line">    Boolean _unused;</span><br><span class="line">    volatile _per_run_data *_perRunData;              // reset for runs of the run loop</span><br><span class="line">    pthread_t _pthread; //runloop对应的线程</span><br><span class="line">    uint32_t _winthread;</span><br><span class="line">    CFMutableSetRef _commonModes;//存储的是字符串，记录所有标记为common的mode</span><br><span class="line">    CFMutableSetRef _commonModeItems;//存储所有commonMode的item(source、timer、observer)</span><br><span class="line">    CFRunLoopModeRef _currentMode;//当前运行的mode</span><br><span class="line">    CFMutableSetRef _modes;//存储的是CFRunLoopModeRef，</span><br><span class="line">    struct _block_item *_blocks_head;</span><br><span class="line">    struct _block_item *_blocks_tail;</span><br><span class="line">    CFAbsoluteTime _runTime;</span><br><span class="line">    CFAbsoluteTime _sleepTime;</span><br><span class="line">    CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，里面有个 _commonModes 的集合，里面存储着被标记为 common 的 Modes 的字符串，主线程的 RunLoop 中，DefaultMode 和 TrackingMode 是被标记为 _commonMode 的。结构体中而且还一个 _commonModeItems 的集合，这个集合里，存储着所有 commonMode 的 item，比如 source、timer、observer。<br>每当 RunLoop 中的内容发生变化时，都会将 _commonModeItems 中的内容，自动同步到被标记为 _commonMode 的 mode 中，比如：<br> 当我们将一个 timer 加入 commonMode，那么他们会被存储到 _commonModeItems 中，然后 RunLoop 会遍历 _commonModes 中的 mode ，然后将 timer 加入到这些 mode 中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSCondition 锁</title>
      <link href="/2018/11/15/NSCondition-%E9%94%81/"/>
      <url>/2018/11/15/NSCondition-%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>最近对于 NSCondition 感到有些疑惑，所以写点东西进行研究一下。 <a id="more"></a></p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>首先 <code>NSCondition</code> 有以下几个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)wait;   让线程陷入睡眠，将锁的权利交出。</span><br><span class="line">- (<span class="built_in">BOOL</span>)waitUntilDate:(<span class="built_in">NSDate</span> *)limit;   让线程睡眠到指定时间</span><br><span class="line">- (<span class="keyword">void</span>)signal;   发送消息唤醒一个睡眠中的线程</span><br><span class="line">- (<span class="keyword">void</span>)broadcast;  发送广播唤醒所有睡眠中的线程</span><br></pre></td></tr></table></figure><h3 id="wait-waitUntilDate"><a href="#wait-waitUntilDate" class="headerlink" title="wait/waitUntilDate:"></a>wait/waitUntilDate:</h3><p>在文档里，对于<code>wait</code>方法的描述是：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blocks the current thread until the condition is signaled.</span><br><span class="line">You must lock the receiver prior to calling <span class="keyword">this</span> method.</span><br></pre></td></tr></table></figure><p>封锁当前线程直到接收到唤醒操作，调用这个方法前，必须先执行<code>lock</code>方法。  </p><p>对于<code>waitUntilDate:</code>的描述如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Declaration</span><br><span class="line">- (<span class="built_in">BOOL</span>)waitUntilDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line"></span><br><span class="line">Parameters</span><br><span class="line">limit</span><br><span class="line">The time at which to wake up the thread <span class="keyword">if</span> the condition has not been signaled.</span><br><span class="line"></span><br><span class="line">Return Value</span><br><span class="line"><span class="literal">YES</span> <span class="keyword">if</span> the condition was signaled; otherwise, <span class="literal">NO</span> <span class="keyword">if</span> the time limit was reached.</span><br><span class="line"></span><br><span class="line">Discussion</span><br><span class="line">You must lock the receiver prior to calling <span class="keyword">this</span> method.</span><br></pre></td></tr></table></figure><p>封锁当前线程，假如在指定时间内未收到唤醒，那么将自动唤醒且返回<code>NO</code>，收到唤醒则返回<code>YES</code>，同样调用这个方法前，必须先执行<code>lock</code>方法。</p><h3 id="signal-broadcast"><a href="#signal-broadcast" class="headerlink" title="signal/broadcast"></a>signal/broadcast</h3><p><code>signal</code>描述如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Signals the condition, waking up one thread waiting on it.</span><br><span class="line"></span><br><span class="line">Declaration</span><br><span class="line">- (<span class="keyword">void</span>)signal;</span><br><span class="line"></span><br><span class="line">Discussion</span><br><span class="line">You use <span class="keyword">this</span> method to wake up one thread that is waiting on the condition. You may call <span class="keyword">this</span> method multiple times to wake up multiple threads. If no threads are waiting on the condition, <span class="keyword">this</span> method does nothing.</span><br><span class="line"></span><br><span class="line">To avoid race conditions, you should invoke <span class="keyword">this</span> method only <span class="keyword">while</span> the receiver is locked.</span><br></pre></td></tr></table></figure><p>发送唤醒信号，唤醒一个等待中的线程，可以多次发送唤醒多个睡眠中的线程，假如没有等待的线程，这个方法 does nothing ~ 为了线程安全，必须先执行 <code>lock</code>方法。</p><p><code>broadcast</code>描述如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Declaration</span><br><span class="line">- (<span class="keyword">void</span>)broadcast;</span><br><span class="line"></span><br><span class="line">Discussion</span><br><span class="line">If no threads are waiting on the condition, <span class="keyword">this</span> method does nothing.</span><br><span class="line"></span><br><span class="line">To avoid race conditions, you should invoke <span class="keyword">this</span> method only <span class="keyword">while</span> the receiver is locked.</span><br></pre></td></tr></table></figure><p>即唤醒所有等待中的线程。</p><h2 id="疑惑点"><a href="#疑惑点" class="headerlink" title="疑惑点"></a>疑惑点</h2><p>看到这里我有几个疑惑：</p><ol><li><code>wait</code>方法是否是将锁的权利交了出去？ </li><li><code>signal</code>后被唤醒的线程是否立即可以执行操作了呢？还是等待锁被释放才能进行进一步操作呢？  </li></ol><p>带着这两个疑惑我写了下面的代码进行测试：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSCondition</span> *lock = [<span class="built_in">NSCondition</span> new];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    [lock lock];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"A线程加锁"</span>);</span><br><span class="line">    [lock wait];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"A线程被唤醒"</span>);</span><br><span class="line">    [lock unlock];</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [lock lock];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"B线程加锁"</span>);</span><br><span class="line">        [lock signal];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"B线程唤醒"</span>);</span><br><span class="line">        [lock unlock];</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-11-16 00:01:39.090049+0800 VoucherCollection[69550:12039642] A线程加锁</span><br><span class="line">2018-11-16 00:01:40.090205+0800 VoucherCollection[69550:12039641] B线程加锁</span><br><span class="line">2018-11-16 00:01:40.090587+0800 VoucherCollection[69550:12039641] B线程被唤醒</span><br><span class="line">2018-11-16 00:01:40.090907+0800 VoucherCollection[69550:12039642] A线程唤醒</span><br></pre></td></tr></table></figure><p>可以看出，A 线程睡眠后，B 线程会获取到锁，说明<code>wait</code>操作会把锁的权利交出去，解答了第一个疑惑。</p><p>然后我们将 B 线程中的最后一句注释掉，变成：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">            [lock lock];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"B线程加锁"</span>);</span><br><span class="line">            [lock signal];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"B线程唤醒"</span>);</span><br><span class="line"><span class="comment">//            [lock unlock];</span></span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>打印结果如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-11-16 00:06:57.739508+0800 VoucherCollection[69640:12056072] A线程加锁</span><br><span class="line">2018-11-16 00:06:58.739682+0800 VoucherCollection[69640:12056073] B线程加锁</span><br><span class="line">2018-11-16 00:06:58.740058+0800 VoucherCollection[69640:12056073] B线程唤醒</span><br></pre></td></tr></table></figure><p>可以看到 B 在执行唤醒操作后没有进行解锁，这时候 A 没有执行唤醒后的后续操作。这说明，A 被唤醒后，因为没有锁的权利，只能等待锁被 B 释放掉才能执行后续操作，这时候 A 才又获取到了锁的权利。  </p><p>这里还有个前提需要注意，假如 A 在被唤醒的时候，还有其他的线程在占用锁，同样 A 要进行等待，可以验证一下:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSCondition</span> *lock = [<span class="built_in">NSCondition</span> new];</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    [lock lock];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"A线程加锁"</span>);</span><br><span class="line">    [lock wait];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"A线程唤醒"</span>);</span><br><span class="line">    [lock unlock];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [lock lock];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"B线程加锁"</span>);</span><br><span class="line">        [lock signal];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"B线程唤醒"</span>);</span><br><span class="line">        [lock unlock];</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [lock lock];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"C线程加锁"</span>);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        [lock unlock];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打印结果如下：    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-11-16 00:19:41.909029+0800 VoucherCollection[69838:12094270] A线程加锁</span><br><span class="line">2018-11-16 00:19:43.006895+0800 VoucherCollection[69838:12094271] B线程加锁</span><br><span class="line">2018-11-16 00:19:43.007118+0800 VoucherCollection[69838:12094271] B线程唤醒</span><br><span class="line">2018-11-16 00:19:43.007295+0800 VoucherCollection[69838:12094273] C线程加锁</span><br><span class="line">2018-11-16 00:19:46.011014+0800 VoucherCollection[69838:12094270] A线程唤醒</span><br></pre></td></tr></table></figure><p>可以看出，只有 C 解锁以后 A 才会执行。</p><h2 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h2><p>生产者生产，消费者消费，缓存区是固定大小的。<br>以下是用<code>NSCondition</code>实现的该模式：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSCondition</span> *lock = [<span class="built_in">NSCondition</span> new];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 模拟消费者</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">        [lock lock];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.arr.count == <span class="number">0</span>) &#123;</span><br><span class="line">            [lock wait];</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span>.arr removeLastObject];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="keyword">self</span>.arr);</span><br><span class="line">        [lock signal];</span><br><span class="line">        [lock unlock];</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 模拟生产者</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">        [lock lock];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.arr.count &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">            [lock wait];</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span>.arr addObject:<span class="string">@"new resource"</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="keyword">self</span>.arr);</span><br><span class="line">        [lock signal];</span><br><span class="line">        [lock unlock];</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对于单生产者单消费者，这些应该是没问题的，多对一或者多对多的情况，改天再分析~</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18.11.15 面试复盘</title>
      <link href="/2018/11/15/18-11-15-%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/"/>
      <url>/2018/11/15/18-11-15-%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p>今天这次记录是时间最短的一个，我提前 15 分钟到了面试地点，半个小时就面完了，面试官很温柔，应该是移动端负责人，非 iOS 出身，对技术的提问也是浅尝辄止，主要是考察被面试者的项目经验，逻辑思维等。 <a id="more"></a></p><h3 id="OC-的内存管理原理"><a href="#OC-的内存管理原理" class="headerlink" title="OC 的内存管理原理"></a>OC 的内存管理原理</h3><p>老生常谈，内存计数的原理，ARC，及注意点。</p><h3 id="瀑布流的实现"><a href="#瀑布流的实现" class="headerlink" title="瀑布流的实现"></a>瀑布流的实现</h3><p>实现原理，基本都是 UICollectionView ，主要是下次请求的时间，和计算 cell 的高度上面。</p><h3 id="埋点的实现"><a href="#埋点的实现" class="headerlink" title="埋点的实现"></a>埋点的实现</h3><p>正好我们公司自定义了埋点，约定字段含义，存储数据库，同时有一个上发策略。</p><h3 id="屏幕掉帧的原因和解决方法"><a href="#屏幕掉帧的原因和解决方法" class="headerlink" title="屏幕掉帧的原因和解决方法"></a>屏幕掉帧的原因和解决方法</h3><p>屏幕渲染的流程，包括 CPU 计算和绘图，交给 GPU 渲染，包括屏幕缓冲区。</p><h3 id="AF-的使用"><a href="#AF-的使用" class="headerlink" title="AF 的使用"></a>AF 的使用</h3><p>封装，底层倒是没考察，这也进一步验证了 AF 在面试中的重要性。</p><h3 id="MVVM-的使用"><a href="#MVVM-的使用" class="headerlink" title="MVVM 的使用"></a>MVVM 的使用</h3><p>这个框架的需求等。</p><h3 id="项目的开发流程"><a href="#项目的开发流程" class="headerlink" title="项目的开发流程"></a>项目的开发流程</h3><p>敏捷开发 每天过进度 找到滞后点。</p><h3 id="负责的事情"><a href="#负责的事情" class="headerlink" title="负责的事情"></a>负责的事情</h3><p>需求 分配 把控周期。</p><h3 id="Swift-划重点"><a href="#Swift-划重点" class="headerlink" title="Swift/划重点"></a>Swift/划重点</h3><p>需要了解一下，好多问到的了，包括有没有上线的项目等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18.11.13 面试复盘</title>
      <link href="/2018/11/15/18-11-13-%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/"/>
      <url>/2018/11/15/18-11-13-%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p>这次面试主要针对基础，暴露了一部分更底层的问题，题目就只写我回答不好的。<a id="more"></a></p><h2 id="笔试题目"><a href="#笔试题目" class="headerlink" title="笔试题目"></a>笔试题目</h2><ol><li>assign 和 weak 的区别，延伸出来就是为什么 weak 可以自动置为 nil ，为什么 assign 不会？主要是 assign 为什么不会？</li><li>程序的存储区域有哪些，堆和栈的区别，什么存储在堆上，什么存储在栈上？</li><li>为什么 c 数组类型不可变，OC 数组可变，有什么区别？</li><li>property 的本质是什么，@sychronize 和 @dynamic 又会做什么？</li><li>load 方法 和 initialize 方法的调用时机，顺序，注意点分别是什么？</li><li>通知 跟 delegate 的区别，什么时候用 通知，什么时候用 delegate ，通知是同步的还是异步的？底层实现是什么？</li><li>页面之间传值的方式有哪些，block 和 delegate 的区别是什么，为什么 delegate 可以找到准确的方法传值？</li><li>快排的思想，和优化，时间和空间复杂度是多少，递归的时间复杂度和空间复杂度是多少？</li><li>NSTimer 的使用注意点是什么，实际底层原理是什么？延时的多种实现方式和区别是什么？</li><li>多线程安全怎么保证，有哪些锁，各有什么特点，OC 属性的 atomic 线程安全吗，底层实现是什么？</li><li>进程和线程的理解。</li><li>组件化怎么实现模块间通信和解耦？</li><li>离屏渲染，什么时候会离屏渲染？什么是离屏渲染，主线程的渲染流程是什么？怎么优化离屏渲染？</li><li>多线程之间共享内存吗？</li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><ol><li>assign 可以修饰基本数据类型跟对象类型，但是 weak 只能修饰对象类型，一般来说用 assign 修饰基本数据类型，weak 指针指向的对象，被销毁时，weak 指针会被置为 nil，因为 Runtime 维护了一个 hash 表，key 是指向对象的地址，Value 是所有指向这个地址的 weak 指针的数组，当我们初始化一个 weak 指针的时候，在这个表里会记录下来，释放时，会根据释放对象的地址，找到对应的 weak 指针数组，遍历这个数组将其置为 nil，同时从表里删除。<br>而 assign 对应的所有权修饰符是 __unsafe_unretain,不会对对象进行 retain 操作，假如这个对象销毁了，有可能会发生野指针错误。对象中存储所有的属性和 isa 指针，假如属性是 assign 修饰的基本数据类型，值被拷贝到了对象中，也就是堆中，假如属性是 assign 修饰的对象类型，拷贝到对象中的是指针，指向堆中的地址，这个地址有可能被释放掉。</li><li>代码区：编译时确定，存储着应用程序的代码。<br>数据区：存放全局变量，静态变量，常量。<br>BSS 段：存储未初始化的全局变量，静态变量。<br>栈区：局部变量、基本数据类型，都存储在栈上是由系统进行内存管理的，函数执行完毕以后，栈会自动的释放该变量，栈比较小，当执行某个方法的时候，栈会为方法需要的内存开辟空间，结束后尾指针指向栈顶从而释放空间。每个线程都有自己的栈空间。<br>堆区：只有堆上的对象类型才会有内存管理，需要手动去进行内存管理，堆是链表进行管理的，系统有一个存储空闲内存地址的链表，分配空间时，去查找这个链表，找到第一个满足的节点。多线程会共享堆空间。  </li><li>因为 OC 数组中存储的是指针，指针指向的对象是可以类型不同的。</li><li>property 是在编译期间，由 Xcode 帮助生成 _成员变量 getter 和 setter 方法，默认 @sychronize var = _var，@sychronize 表示由系统生成 getter 和 setter 方法，同时可以自定义 property 生成的成员变量名称，如 @sychronize var; 就会生成叫 var 的成员变量。@dynamic 表示不生成 getter 和 setter 方法，由我们自己生成。  </li><li>load 方法，当类被引入到项目的时候就会调用，main 函数执行之前，每个类的 load 方法只会调用一次，执行顺序是 superClass -&gt; subClass -&gt; category，load 函数是系统自动调用的，不需要调用父类。注意不要在其中使用其他类，因为不保证其他类已经执行了 load 方法。一般在里面实现 方法交换。<br>initialize 方法，只有在给这个类发送消息的时候，才调用一次，当子类没有实现方法时，会调用两次父类的方法，子类会覆盖掉父类的实现，分类也会覆盖掉主类的实现。</li><li>通知是同步的，即发送通知后，会执行注册的方法，执行完才会继续向下执行。</li><li>从使用场景区分，当有多个回调方法的时候，写一个 delegate 就可以，而需要写多个 block，比如 self.delegate 可以执行多个方法，但是 self.block 只能执行一个代码块。<br>从效率上看，block 消耗更多，delegate 消耗比较少。</li><li>快速排序时间复杂度是 O(nlogn) 空间复杂度是 O(logn)，即递归的深度。递归的空间复杂度是 O(n)</li><li>循环引用，滑动时会被停止，使用 timerWith 方法创建的 NSTimer ，必须手动加到线程的 runLoop 中才会执行，或者执行点的时候，runLoop 还在运行其他的，会跳过执行点。CADisplayLink ，屏幕刷新的时候调用，依托于屏幕刷新频率，假如跳帧，会受到影响。GCD 定时器，不受 runloop mode 切换的影响，但是也有可能会被阻塞。<br>延时操作有三种，NSTimer ，performSelector:afterDelay: ,GCD 的 dispatch_after，前两种都是创建一个 timer 到 runloop 中，主线程可以，但是子线程默认没有 runloop 的，需要手动开启一个 runloop ，GCD 的 dispatch_after 可以不受 runloop 的影响，将执行代码一段时间后加入到队列中。  </li><li>@sychronized 互斥锁，对象级别，atomic 就是用这个实现的对 getter 和 setter 加锁，但是也不能保证线程安全，可能会绕过这两个方法对属性进行改变。<br>自旋锁，一个死循环，循环等待，效率最高，但是有线程安全问题。<br>信号量，通过信号机制进行加锁，等待的线程会睡眠。<br>互斥锁，加锁后，其他线程睡眠，直到解锁。  </li><li>进程可以认为是一个 程序。<br>线程是进程中执行运算的最小单位，每个进程都有一个主线程，每个线程肯定只属于一个进程。每个进程都是串行执行任务的，为了并发执行，要开启多个线程进行操作。</li><li>通过中介者</li><li></li><li>每个线程都有自己的栈，管理自己的状态和局部自动变量，共享堆区。 </li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>18.11.12 面试复盘</title>
      <link href="/2018/11/15/18-11-12-%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/"/>
      <url>/2018/11/15/18-11-12-%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p>第一家试水，明显没状态。。 <a id="more"></a></p><h2 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h2><h3 id="数组求中间值下标"><a href="#数组求中间值下标" class="headerlink" title="数组求中间值下标"></a>数组求中间值下标</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>已知一个数组，求得第一个下标，使得左边累加的和  跟 右边累加的和相同，要求时间复杂度为 O(n)。<br>例：<br>输入 a = [10,20,5,65,20,15] 输出为 3   </p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题最先想到的是嵌套循环，每次都求出下标左方的和，跟右方的和做对比，但是这样的时间复杂度是 O(n^2) 。<br>有个思路是这样： 先求出总和 sum ，接着遍历，并且记录当前坐标左侧元素和 leftSum ，假如 leftSum * 2 = sum - [当前下标值] ,那么肯定右边的元素值相加和 rightSum，即与 leftSum 值相同。OC 的实现如下：</p><pre><code><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">NSInteger</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">NSInteger</span> index = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">NSArray</span> *arr = @[@(<span class="number">10</span>),@(<span class="number">20</span>),@(<span class="number">5</span>),@(<span class="number">60</span>),@(<span class="number">22</span>),@(<span class="number">13</span>)];</span><br><span class="line"><span class="built_in">NSInteger</span> leftSum = ((<span class="built_in">NSNumber</span> *)arr[<span class="number">0</span>]).integerValue;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; arr.count; i ++) &#123;</span><br><span class="line">    sum += ((<span class="built_in">NSNumber</span> *)arr[i]).integerValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">1</span>; i &lt; arr.count - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * leftSum == (sum - ((<span class="built_in">NSNumber</span> *)arr[i]).integerValue)) &#123;</span><br><span class="line">        index = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    leftSum += ((<span class="built_in">NSNumber</span> *)arr[i]).integerValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> index;</span><br></pre></td></tr></table></figure></code></pre><h3 id="8进制-转-10进制-转-26进制"><a href="#8进制-转-10进制-转-26进制" class="headerlink" title="8进制 转 10进制 转 26进制"></a>8进制 转 10进制 转 26进制</h3><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>输入一个 8 进制数，转换为相应的 a-z 的字符串，a 对应 1 ，z 对应 26，aa 对应 27，aaa 对应 703。<br>例：<br>输入 32，输出 z </p><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个题其实描述让我头大了一会，其实这之间存在了 10 进制的中间进制，比如 a-z 对应 1-26 ,27 对应 aa ,27 其实是 10 进制，那这道题我理解的考察思路是 8 进制转换为 10 进制，然后再转化为 <code>伪26进制</code> ，为啥有个 伪 呢，我们平常接触到的 2 进制，8 进制，都是从 0 开始的，例如 8 进制 ： 0 1 2 3 4 5 6 7 10 11 … 从 0 开始，到达 7 以后进一位，但是这个 a-z,反而从 1 开始 ，到 26 结束。  </p><ol><li>8 进制转化为 10 进制</li><li>10 进制转化为 26 进制</li><li>得到的数，再去从低位到高位依次匹配</li></ol><p>第三部分的匹配，有个问题，那就是 10 进制 26，转化为 26 进制是 10 ，怎么去跟 z 匹配呢，延伸出来的问题，就是 0 这个数，用哪个字符代表呢？比如 26 * 26 = 676，转化为 26 进制为 100，用什么字符串代表呢？题中没有给出描述，我还没有得出好的解决思路。</p><h3 id="银行顾客等待时间"><a href="#银行顾客等待时间" class="headerlink" title="银行顾客等待时间"></a>银行顾客等待时间</h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>银行有 4 个柜台，已知每个客户到达时间为数组 a ，每个客户处理时间为数组 p ，每个柜台一次只能接待一个客户，每次叫号都接待排号最前的用户，求所有用户的平均等待时间。<br>例：<br>a = [1,2,3,4,4,8]  p = [50,20,11,25,30,40]<br>输出：平均等待时间为 24/6 = 4</p><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>我的思路是这样，因为柜台数量是固定的，每次有新的顾客来，四个里面肯定有一个最早结束的柜台，这个顾客肯定会被这个最早结束的柜台招待。问题就是怎么找到这个最早结束的柜台。<br>假如有 n 个柜台，我们可以创建一个固定数量为 n 的数组 a ，它里面存储着每个柜台的结束点，即为 到达时间+处理时间，每次来了顾客，接待这个顾客的肯定是最小结束点所在的柜台，用 到达点 去跟 最小结束点 比较，假如大于 最小结束点，就表示不需要等待，否则需要等待，等待时间为 最小结束点减去到达点，同时需要刷新最小结束点，并且更新这个最小结束点为新的结束点(加上处理时间)，并求出新的最小结束点，因为有可能会有变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    NSArray &lt;NSNumber *&gt;*a = @[@(1),@(2),@(3),@(4),@(4),@(8)];</span><br><span class="line">    NSArray &lt;NSNumber *&gt;*p = @[@(50),@(20),@(11),@(25),@(4),@(40)];</span><br><span class="line">    NSMutableArray &lt;NSNumber *&gt;*endTimeArr = [NSMutableArray new];</span><br><span class="line">    NSInteger n = 4;            /// 柜台数</span><br><span class="line">    NSInteger waitSum = 0;      /// 等待总时间</span><br><span class="line">    NSInteger minEndTimeIndex = 0;   /// 最小结束点下标</span><br><span class="line">    </span><br><span class="line">    /// 初始化结束点数组</span><br><span class="line">    for (NSInteger i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">        [endTimeArr addObject:[NSNumber numberWithInteger:a[i].integerValue + p[i].integerValue]];</span><br><span class="line">    &#125;</span><br><span class="line">    /// 初始化最小结束点下标</span><br><span class="line">    minEndTimeIndex = [self findMinestIndex:endTimeArr];</span><br><span class="line">    </span><br><span class="line">    /// 循环剩下的元素</span><br><span class="line">    for (NSInteger i = n; i &lt; a.count; i ++) &#123;</span><br><span class="line">    /// 假如该到达点小于最小结束点，说明需要等待，等待时间为两者差。</span><br><span class="line">        if (a[i].integerValue &lt; endTimeArr[minEndTimeIndex].integerValue) &#123;</span><br><span class="line">            waitSum += endTimeArr[minEndTimeIndex].integerValue - a[i].integerValue;</span><br><span class="line">        &#125;</span><br><span class="line">        /// 更新这个下标所在的值，增加处理时间。</span><br><span class="line">        endTimeArr[minEndTimeIndex] = [NSNumber numberWithInteger:endTimeArr[minEndTimeIndex].integerValue + p[i].integerValue];</span><br><span class="line">        /// 更新最小结束点下标，因为增加处理时间后，可能会发生变化了，面试的时候我竟然晕了？？？</span><br><span class="line">        minEndTimeIndex = [self findMinestIndex:endTimeArr];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CGFloat averageWaitTime = (float)waitSum / n;</span><br><span class="line">    return averageWaitTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)findMinestIndex:(NSArray &lt;NSNumber *&gt;*)arr</span><br><span class="line">&#123;</span><br><span class="line">    NSInteger index = 0;</span><br><span class="line">    for (int i = 1; i &lt; arr.count; i ++) &#123;</span><br><span class="line">        if (arr[i].integerValue &lt; arr[index].integerValue) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是具体的 OC 代码，这个题还是挺简单的，但是面试的时候，让人问晕了 T_T ，明明已经实现出来的代码，讲的时候竟然还能讲迷糊。</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="介绍一下你自己"><a href="#介绍一下你自己" class="headerlink" title="介绍一下你自己"></a>介绍一下你自己</h3><p>我叫侯文杰，92 年出生，14 年 毕业于山东理工大学计算机科学与技术专业，从事 iOS 开发已经 4 年了，之前做的项目都是电商类的，最近的一次工作经历是在地球港，作为 iOS 开发小组的组长，我们团队不是特别多，3 个人，我负责整个项目前期架构的搭建和优化，开发期间进行业务需求的评审，分配任务，完成项目的主要购买流程，并负责同事代码的 review ，打包上线。</p><h3 id="离职原因"><a href="#离职原因" class="headerlink" title="离职原因"></a>离职原因</h3><p>跟我的职业发展规划有点不符合吧，因为一直在小公司，小规模的团队，虽然可以培养解决问题的能力，但是眼界上得不到提升，很多问题不上升到一定规模，不会暴露出来，所以我想接触大型团队，感受下专业团队开发的氛围，让自己更加专业吧。<br>职业规划：毕业这几年积累技术，30 岁之前熟悉规模化的开发流程，做到 30 岁成为一个技术专家，可以带团队。  </p><h3 id="作为开发小组-leader-，你觉得最重要职责的是什么"><a href="#作为开发小组-leader-，你觉得最重要职责的是什么" class="headerlink" title="作为开发小组 leader ，你觉得最重要职责的是什么"></a>作为开发小组 leader ，你觉得最重要职责的是什么</h3><p>作为小组 leader ，主要的工作不再仅仅是开发，而是要对项目做到 可控 ，简单来说就是要对每次开发周期自己有把控。  </p><ol><li>最开始的需求评审：找到需求的不合理地方，需要明确的地方，也包括后端接口是不是支持。  </li><li>针对每个人进行开发任务的分配，要做到对每个人的具体工作能力有深入了解，而且把需求具体化，任务化，能够做到按时间划分。</li><li>任务优先级，每次开发周期可能有不同的需求同时进来，我们要理清哪个优先级是最高的。</li><li>关注开发进度，实时关注开发进度，遇到问题都要实时暴露出来去找解决办法。</li></ol><h3 id="项目概况-团队人数-负责的项目个数"><a href="#项目概况-团队人数-负责的项目个数" class="headerlink" title="项目概况 团队人数 负责的项目个数"></a>项目概况 团队人数 负责的项目个数</h3><h3 id="针对于购物车的缓存方案实现及具体流程"><a href="#针对于购物车的缓存方案实现及具体流程" class="headerlink" title="针对于购物车的缓存方案实现及具体流程"></a>针对于购物车的缓存方案实现及具体流程</h3><h3 id="针对于界面的具体优化"><a href="#针对于界面的具体优化" class="headerlink" title="针对于界面的具体优化"></a>针对于界面的具体优化</h3><h4 id="CPU-的密集使用"><a href="#CPU-的密集使用" class="headerlink" title="CPU 的密集使用"></a>CPU 的密集使用</h4><ol><li>对象创建、调整、销毁</li><li>布局计算，autolayout 提前计算，防止大量调整，尽量使用 frame</li><li>文本计算渲染 可以通过后台线程 CoreText</li><li>图片解码，图片设置到 ImageView 中或者 CALayer 中时，才会解码，可以事先绘制到 CGBitmapContext 中，需要的时候直接创建图片。  </li></ol><h4 id="GPU-的消耗原因"><a href="#GPU-的消耗原因" class="headerlink" title="GPU 的消耗原因"></a>GPU 的消耗原因</h4><p>GPU 主要负责纹理的变换、混合、渲染    </p><ol><li>纹理的渲染 尽量减少短时间内大量图片的显示</li><li>减少视图的层次和数量</li><li></li></ol><h2 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h2><p>可以看出来，这家公司问的都是 算法 + 具体项目 ，丝毫没有考察 OC 相关的东西，说明面试官应该不是 iOS 开发人员，嗯，，心理素质还不行吧，自从讲解迷糊之后，脑袋转不动了哈哈，这几天我的准备偏向于 OC 底层跟基础，还是得拿出点时间针对于自己的项目做优化和准备。<br>比如：数据库的线程安全，购物车缓存的实现，UI 的优化。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>18.11.14 面试复盘</title>
      <link href="/2018/11/14/18-11-14-%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/"/>
      <url>/2018/11/14/18-11-14-%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p>一面 ： 内存管理，运行时，类的加载顺序，多线程，小算法。<br>二面 ：数据库 AF JSPatch HTTPS  <a id="more"></a></p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="一面题目"><a href="#一面题目" class="headerlink" title="一面题目"></a>一面题目</h3><ol><li>通知是同步的吗？子线程中发通知，执行的监听方法，是在哪个线程中执行的？</li><li>同步或者异步执行串行队列会生成子线程么，同步或者异步执行并行队列会生成子线程么？重点多了解一下 Dispatch，包括各种用法等。</li><li>NSTimer 为什么会强引用？假如 target 是 weak 修饰的会强引用吗，在 dealloc 里注销 timer 可以么？ dealloc 的调用时机。</li><li>load 方法的加载时机，里面可以访问分类的方法吗，子类的 load 方法调用时，分类已经加载到运行时了吗？</li><li>category 怎么添加属性，关联对象的内存管理，关联一个 int 类型怎么释放掉？</li><li>class 方法 和 object_getClass 方法的区别。</li><li>super 实际上是什么？</li><li>消息转发机制。</li><li>项目中有没有遇到什么问题，怎么解决的？</li><li>图片怎么加载到内存中的，假如一张图片 30k ，在手机内存中实际占据的空间大小是多少？</li><li>JSPatch 或者 JS 的交互，是怎么实现的？</li><li>平时项目总用户是多少？日活是多少？bug 率是多少？假如线上出现了 bug ，怎么快速定位到，有没有好的技术方案快速定位到 bug 出错点？</li><li>合并有序数组。</li><li>抓包工具，Charles 的了解和使用。</li><li>sourceTree 中遇到的比较棘手的问题。git 命令</li></ol><h3 id="二面题目"><a href="#二面题目" class="headerlink" title="二面题目"></a>二面题目</h3><ol><li>判断字符串是否是回滚字符串，例： abbiuibba ,延伸，假如是数字，并要求时间和空间复杂度最小。</li><li>深入了解 AF 包括网络的 cookie session 的原理，AF 最多接受多少域名？</li><li>HTTPS</li><li>项目中用到的数据库，为什么要用数据库存储数据？数据库的表结构是怎样的？</li><li>针对于防止中间人攻击，数据加密等是怎么做的，或者怎么缓存的。</li><li>数据结构，二叉树的层次遍历。</li><li>组件化的实现，通信和怎么解耦的？</li><li>感觉自己闪光点在哪里？</li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ol><li><p>通知是同步的，不管在哪个线程注册通知，发送通知的时候，只会跟发送时所在的线程相关，比如在子线程中发出通知，执行的方法是在子线程里面；在主线程里发通知，执行的方法是在主线程里。</p></li><li><p>看下面的代码： </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    NSLog(@&quot;并行队列异步执行:%@&quot;,[NSThread currentThread]); /// 产生新线程</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    NSLog(@&quot;并行队列同步执行:%@&quot;,[NSThread currentThread]); /// 打印的是主线程</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;串行队列异步执行:%@&quot;,[NSThread currentThread]); /// 主线程</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;serialQueue&quot;, NULL);</span><br><span class="line">dispatch_async(serialQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;串行队列异步执行:%@&quot;,[NSThread currentThread]); /// 线程一</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(serialQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;串行队列异步执行:%@&quot;,[NSThread currentThread]); /// 线程一 两次执行都是在子线程中执行，说明，每个 serialQueue 都最多产生一个子线程，</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;串行队列同步执行:%@&quot;,[NSThread currentThread]); /// 打印的是主线程</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;串行队列同步执行:%@&quot;,[NSThread currentThread]); /// 打印的是主线程</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以统计出:  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">               串行队列                并行队列</span><br><span class="line">async异步  每个queue最多一个线程         产生新线程</span><br><span class="line">sync同步        当前线程                当前线程</span><br></pre></td></tr></table></figure><p>对 sync 同步函数来说，把任务同步的放到并行队列还是串行队列，实际上都是在当前线程，也就是 sync 操作处在的线程中，并没有产生新线程。<br>对 async 异步函数来说，把任务异步放到并行队列里，肯定会产生新线程，放到一个串行队列里，不会产生新线程，每次生成一个串行队列，都对应了一个线程(非主线程)，async 不会再多生成一个线程。<br>还有个问题，这四种情况下，任务到底是同步还是异步执行呢?</p><ul><li>async + 并行队列，肯定是并行执行。  </li><li>async + 串行队列，串行执行。  </li><li>sync 更简单了，因为都是在同一个线程里处理，肯定都是串行执行。</li></ul><p>要注意，一个线程一次肯定只能执行一个任务，肯定是按照顺序执行的。<br>dispatch 其实也会对内部使用的对象进行强引用，但是没有循环引用的关系就可以。</p></li><li><p>NSTimer 会对 target 进行一个强引用，即使将 target 置为一个 weak 指针，也会对齐指向的对象进行一个强引用，而且即使 target 不对 timer 进行引用，也会发生内存泄漏，因为 timer 会被 runloop 所持有，从而导致 timer 不会释放，继而导致 target 不会释放。delloc 只有当对象销毁时才会调用，不会销毁，当然不会调用。有好多解决 timer 的方案：  </p><ul><li>开发的时候规范化，初始化一个 timer ，就记得把它 invalidate 和 置为 nil 注销掉。  </li><li>iOS 10.0 之后，提供了 block 的初始化方法，这个里面，只要防止 block 对 target 进行引用就好了，但是针对 timer 还是要 invalidate 和 置为 nil。  </li><li>当 A 使用 timer 的时候，找一个中间者去生成它，这个中间者 B 随着A的释放而释放，在 dealloc 中对 timer 进行销毁，timer 的 target 被 B 弱引用，timer 执行方法的时候，target 里实现消息转发，转发到真正的使用者 A 中，<a href="https://github.com/eassy/LibraryImgs/blob/master/%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/WechatIMG50.jpeg" target="_blank" rel="noopener">图片</a>中讲解的更详细。  </li></ul></li><li><p>load 方法，调用在运行时把类加载以后，main 函数之前，即类的方法列表已经加载好了，里面也有分类的方法，这个时候可以调用自己分类的方法，load 方法是系统自动调用的，而且是通过使用函数内存地址的方式，而不是使用 objc_msgSend 的方式，所以 load 方法不会被覆盖掉。其实这个时候，所有的类都加载到运行时里面了，也可以调用其他类的方法，但是假如其他类的方法依赖于自身的 load ，就可能会出错。<br>initialize 方法，只有在 类或子类收到第一条送消息时会调用，包括实例方法和类方法，在调用自己的实现时，会先循环递归调用父类的实现，然后再调用 objc_msgSend 方法，所以假如子类没有实现，收到第一条消息的时候，会先递归调用父类的方法，接着 objc_msgSend ，发现自己没有这个实现，然后找到 父类的方法进行调用，这两次的调用区别在哪里？在于第一次，是父类执行这个方法，而第二次，是子类执行这个方法。而且，也会被分类实现的 initialize 方法所覆盖掉。  </p></li><li><p>对一个对象添加 关联对象 实际上是在一张全局表中，将 关联对象跟对象做了绑定，这张表存储着某个对象所有的对应关系，内存缓存策略表明了这个关联对象什么时候释放，假如是 retain ，那么这个关联对象跟随着主对象释放而释放，假如是 assign ，分两种情况：</p><ul><li>关联对象是自定义的对象或者普通对象   alloc 以后超出作用域就会释放</li><li>NSString NSNumber 不会释放，即再次请求的时候不会野指针。</li></ul><p>第二种很奇怪，我暂时还没搞清楚。</p></li><li><p>object_class 运行时底层，是返回了这个对象里的 isa 指针，对于一个对象来说，isa 指针是自己的类，对于类来说，isa 指针是自己的元类。<br>而在 NSObject 的实现里，实例方法 class ，和类方法 class 的实现如下：  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)class &#123;</span><br><span class="line">   return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)class &#123;</span><br><span class="line">    return object_getClass(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，实例方法的 <code>-class</code> ，其实就是调用了 <code>object_getClass()</code>，返回的是自己的 isa 指针，即类，对类再进行调用，返回的就是元类。而类方法 <code>+class</code>，返回的是自己本身，即类。  </p></li><li><p>当一个对象接收到没有实现的消息时，会有下面几个阶段：</p><ol><li>查找父类</li><li>动态解析</li><li>消息重定向到某个对象</li><li>回调传回一个包装好的消息，允许我们做进一步转发。</li></ol></li><li><p>super ，实际上是一个编译器指示符，遇到时，编译器生成一个结构体：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct objc_super &#123;</span><br><span class="line">   id receiver;</span><br><span class="line">   Class superClass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 这个结构体保存有一个 <code>receiver</code> 指针指向子类，还有一个指向 <code>superClass</code>的Class 指针，当我们调用 <code>[super message]</code> 方法时，编译器转为：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSendSuper(struct objc_super *super, SEL op, ...)</span><br></pre></td></tr></table></figure><p> 内部可能是拿 <code>receiver</code> 和 根据 <code>receiver</code> 和 <code>superClass</code>、<code>sel</code>，找到的方法，去做的方法调用，可能会使用 <code>objc_msgSend(id theReceiver, SEL theSelector, ...)</code> 方法，不过这时候，接受者是<code>super-&gt;receiver</code>。 </p></li><li><p>这个地方是个加分的地方，要好好准备解答。  </p></li><li><p>图片加载到 UIImageView 上，需要以下几步：</p><ul><li>从硬盘中加载到内存中</li><li>将压缩的图片解码成未压缩的位图 CPU 中</li><li>将未被压缩的位图渲染到 UIImageView 上</li></ul><p>位图就是一个像素数组，存储着图片中的每一个点，假如一张图片尺寸为 30 * 30，质量为 30k，那么加载到手机中，解压缩后，原始数据大小其实为：30 * 30 * 4 字节(每个像素占得字节数)。  </p><p>而一张图片的二进制数据，是经过压缩后的位图图形格式，大小就是我们一般说的图片有 30k 大。  </p><p>一般将图片渲染到屏幕上时，必须将他解压缩出来得到原始的位图数据，才能执行后续的渲染工作，解压缩是很耗时的操作，Core Graphics 提供了一个解压缩方法 <code>CGContextRef CGBitmapContextCreate(void *data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef space, uint32_t bitmapInfo);</code> 一般来说一些第三方比如 YYKit、SD 都是使用这个方法在子线程进行了图片预先解压缩，当图片进行了解压缩后，系统就不会再次解压缩了。</p></li><li><p>暂定</p></li><li><p>项目日活大概 3 w，总用户大概 200w ，bug 率 大概 0.2% 。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 协议 与 HTTPS</title>
      <link href="/2017/08/09/HTTP-%E5%8D%8F%E8%AE%AE-%E4%B8%8E-HTTPS/"/>
      <url>/2017/08/09/HTTP-%E5%8D%8F%E8%AE%AE-%E4%B8%8E-HTTPS/</url>
      
        <content type="html"><![CDATA[<p>复习一下网络协议。 <a id="more"></a></p><h2 id="TCP-UDP-协议"><a href="#TCP-UDP-协议" class="headerlink" title="TCP/UDP 协议"></a>TCP/UDP 协议</h2><h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><h4 id="面向连接"><a href="#面向连接" class="headerlink" title="面向连接"></a>面向连接</h4><p>TCP 协议是面向连接的，可靠的传输层协议，可以保证数据正确性和合法性，传输的可靠到达，流量控制。<br>在建立连接的时候，TCP 进行三次握手，释放连接的时候，进行四次挥手。  </p><p>三次握手顺序如下：  </p><ol><li>客户端-&gt;服务端：我将发起连接。  服务端确定了自己的接收能力是 OK 的  </li><li>服务端-&gt;客户端：我已经收到了你的请求。  客户端确定了自己的发送能力和接收能力  </li><li>客户端-&gt;服务端：我接收到了你的回应，马上发送。 服务端确定了自己的发送能力。</li></ol><p>四次挥手：  </p><ol><li>客户端-&gt;服务端：我没有数据发送了，你先发送剩下的，完事告诉我。</li><li>服务端-&gt;客户端：好的，我发送完了告诉你。</li><li>服务端-&gt;客户端：我发送完了，你收到信息就可以断开连接了。</li><li>客户端-&gt;服务端：好的，你也断开吧。客户端在等待一定时间保证网络上没有未到达的数据包后，断开连接。  </li></ol><p>为什么要四次挥手，因为客户端请求断开连接的时候，只是说明自己没有数据要发送了，但是自己还可以接受，服务端也可能还有数据没有发送完成。<br>所以 TCP 协议是面向连接的，它保证双方都有接受和发送能力。  </p><h4 id="数据可靠性和流量拥塞控制"><a href="#数据可靠性和流量拥塞控制" class="headerlink" title="数据可靠性和流量拥塞控制"></a>数据可靠性和流量拥塞控制</h4><ol><li>校验和 有一个校验和字段，发送方将所有报文分段反码相加，结果存在校验和字段中，接收方收到后同样进行计算，相同则正确。</li><li>序列号 TCP 给每个字节都编号，进行去重、完整性、顺序性的应用。</li><li>确认应答 每次收到请求，接收方都会进行确认，给发送方发送确认报文，里面的确认值表明这个值之前的数据都收到了。</li><li>超时重传 经过一段时间后，发送方没有收到接收方的确认报文，会重新发送。</li><li>流量控制 接收方收到报文后，进行确认应答时，会将自身缓冲区剩余大小放到窗口段中，设置0的话，发送方不再发送数据，同时等待窗口更新的通知，过了超时时间还没有收到的话，会发送窗口探测，查看窗口是否更新完成可以继续发送。</li><li>拥塞控制、慢启动。还有一个拥塞窗口的概念，每次发送，都是发送流量控制窗口和拥塞窗口的最小值。每次拥塞窗口都是从1开始，指数级增长，慢慢发送的越来越多，超过阈值就进行线性增长，出现重传的话，阈值设置为当前拥塞窗口大小的一半，同时进行再次慢启动。</li></ol><h3 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3><p>UDP 协议无法保证可靠性，顺序性，所以传输效率高，处理速度快，所以通常音频和视频数据，可以使用 UDP 协议。</p><h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><p>工作在应用层，基于 TCP 协议实现。</p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>简单来说，服务器在响应头中给浏览器发送 Set-Cookie 段，后期浏览器根据段中的配置，取出 cookie 回传给服务器。每次可以发送多个段，每个段中包含：</p><pre><code>* 名称-值    cookie 的名称和值* Domain 域 = 域名    当前 cookie 可以被发送到哪些域或者子域下面 默认是当前域* Path = 路径    所属的路径* Expires = Date    过期时间未指定过期时间，代表生命周期为当前浏览器，关闭后删除，指定之前的时间，cookie 会立即删除。                 还有一点，假如未设置过期时间，存储在浏览器内存中，否则存储在硬盘上。* Secure    有这个字符串的话，代表只有 https 安全通信时才发送 cookie* HttpOnly 有这个字符串的话，代表此 cookie 只能用于 http 或 https 传输，脚本 js 等是不能访问的。</code></pre><p>浏览器回传给服务器的时候，在请求头发送 Cookie 段，只包含 名称=值 对，多个以分号相隔。<br>下面是一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/// 服务器发送给浏览器，只注重 set-cookie 段</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line"></span><br><span class="line">Content-type: text/html</span><br><span class="line"></span><br><span class="line">Set-Cookie: name=value</span><br><span class="line"></span><br><span class="line">Set-Cookie: name2=value2; Expires=Wed, 09Jun 2021 10:18:14 GMT</span><br><span class="line"></span><br><span class="line">/// 浏览器回传</span><br><span class="line">GET /spec.html HTTP/1.1</span><br><span class="line"></span><br><span class="line">Host: www.webryan.net</span><br><span class="line"></span><br><span class="line">Cookie: name=value; name2=value2</span><br><span class="line"></span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure><p>Cookie 可以做很多事情，因为浏览器已经保存起来了一些信息，比如用户账号缓存，记录用户行为，当然也有安全性缺失等缺点，比如 js 也可以更改存储的 cookie。</p><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>为了在 http 协议上，对客户保存状态，有两种方案，cookie 机制和 session 机制。  </p><p>cookie 机制是在客户端保存状态的机制，而 session 是在服务端保持状态的一个机制。</p><p>当需要为客户端创建一个 session 的时候，服务器会检查客户端请求头中是否包含一个 session-id ，假如有的话就说明以前创建过 session ，根据 session-id 去查找到对应的 session ，假如没有的话，生成一个 session 和与之对应的 session-id，并把 session-id 返回给客户端保存起来。<br>通常，这个 session-id ，是保存在客户端的 cookie 里面的，但是有时候，客户端会把 cookie 禁止掉，这时候可以将 session-id 放到 url 后面上传。<br>至于在 session 里面可以存储什么，这个也是多种多样的。</p><h3 id="HTTP-队首阻塞"><a href="#HTTP-队首阻塞" class="headerlink" title="HTTP 队首阻塞"></a>HTTP 队首阻塞</h3><p>在一个 tcp 连接中，只有多次请求会放到一个队列中，只有上一个请求收到回应完成后，才能发送下一个请求，这样假如前面的数据过大，会引起后面请求被阻塞。</p><h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h3><h4 id="帧-消息-流"><a href="#帧-消息-流" class="headerlink" title="帧 消息 流"></a>帧 消息 流</h4><p>一个帧是传输数据的最小单位，里面有数据，有所属流的标识<br>流可以理解成针对于每个资源的请求<br>一个消息可以理解为一次 HTTP 传输的数据，里面可能包含多个流的多个帧。<br>每次传输一个消息，会一次传输多个流的多个帧，乱序传输，收到后会再次组合，这样实现了多个流即多个资源的并行传输，解决了 http 可能会出现的队首阻塞，但是 tcp 层的阻塞没有处理。</p><h4 id="传输的数据被编码为二进制"><a href="#传输的数据被编码为二进制" class="headerlink" title="传输的数据被编码为二进制"></a>传输的数据被编码为二进制</h4><p>数据被编码为二进制</p><h4 id="多次连接复用一个-TCP-连接"><a href="#多次连接复用一个-TCP-连接" class="headerlink" title="多次连接复用一个 TCP 连接"></a>多次连接复用一个 TCP 连接</h4><p>建立一条 TCP 连接后，可能上面有多个数据流在并行传输。</p><h4 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h4><p>不同于 http 1.x ，每次请求都有一个完整的 head 首部，http 2.0，保存着一个首部表，每次可能只对这个表进行键值对的更新，而且对于数据进行了压缩。</p><h2 id="HTTPS：基于-HTTP-协议的加密实现"><a href="#HTTPS：基于-HTTP-协议的加密实现" class="headerlink" title="HTTPS：基于 HTTP 协议的加密实现"></a>HTTPS：基于 HTTP 协议的加密实现</h2><h3 id="HTTP-协议的短板"><a href="#HTTP-协议的短板" class="headerlink" title="HTTP 协议的短板"></a>HTTP 协议的短板</h3><ol><li>因为 HTTP 协议是明文传输，所以有可能会被窃听</li><li>无法验证同新方的身份，可能遭遇伪装</li><li>无法证明报文的完整性，有可能已遭遇篡改</li></ol><h3 id="HTTPS-协议的解决方法"><a href="#HTTPS-协议的解决方法" class="headerlink" title="HTTPS 协议的解决方法"></a>HTTPS 协议的解决方法</h3><p>HTTPS 是 HTTP 通信接口部分使用 SSL 和 TLS 协议代替。<br>SSL 协议采用公开密钥加密的处理方式进行安全处理，HTTP 协议最开始直接和 TCP 通信，使用 SSL 后，变成先和 SSL 通信，再由 SSL 协议去和 TCP 进行通信。<br>采用 SSL 后，HTTPS 可以进行加密处理和认证，并进行完整性保护，即 HTTP + 加密 + 认证 + 完整性保护 = HTTPS。<br>所以说 HTTPS 并不是一种新的协议，而是 HTTP 采用 SSL 协议，SSL 协议提供这些加密等功能。</p><h3 id="两种加密算法"><a href="#两种加密算法" class="headerlink" title="两种加密算法"></a>两种加密算法</h3><p>共享密钥加密 和 公开密钥加密</p><ol><li>共享密钥加密 也叫对称密钥加密，发送方和接收方都保存有一个密钥，加密和解密都用到密钥，但是如何传输密钥，传输过程中密钥也有可能会被监听窃取。</li><li>共开密钥加密 也叫非对称密钥加密，使用公开密钥加密，发送方使用接收方公布的公开密钥进行加密，接收方使用自己保存的私钥进行解密。</li></ol><h3 id="HTTPS-的具体实现方式"><a href="#HTTPS-的具体实现方式" class="headerlink" title="HTTPS 的具体实现方式"></a>HTTPS 的具体实现方式</h3><p>HTTPS 实现共享密钥加密和公开密钥加密结合的混合加密机制。<br>在传输共享密钥阶段，使用公开密钥加密方式进行交换密钥，之后简历通信交换报文，则使用共享密钥加密方式。</p><h3 id="如何证明公开密钥的正确性"><a href="#如何证明公开密钥的正确性" class="headerlink" title="如何证明公开密钥的正确性"></a>如何证明公开密钥的正确性</h3><p>但是即使使用公开密钥加密，也有问题，那就是在交换公开密钥的时候，也无法证明公开密钥就是真正的密钥，有可能真正的公开密钥被替换掉了。<br>为了解决这个问题，引入了第三方数字证书认证机构，处于客户端和服务器双方都可信赖的第三方机构的立场上。  </p><ol><li>首先，服务器 A 运营人员向数字证书认证机构提出公开密钥的申请，把自己的公开密钥 a 发送给数字证书认证机构。</li><li>数字认证机构 B 用自己的私有密钥向服务器 A 的公开密钥 a 做数字签名，将这个公开密钥放入证书 b 。</li><li>服务器 A 会将这个证书 b 发送给客户端，客户端使用认证机构的公开密钥 b1，对这个证书的数字签名做验证，即验签操作，假如正确，客户端就认为服务器 A 发过来的证书中的公开密钥，是可以信任的。然后客户端发送数据的时候，使用服务器的公开密钥对报文加密后发送，服务器使用自己的私有密钥对报文进行解密。</li></ol><p>这个过程有个前提，就是认证机构的 公开密钥 b1 ，是什么时候传输给客户端的，一般来说浏览器里事先导入了认证机构的公开密钥。</p><h3 id="单向认证和双向认证"><a href="#单向认证和双向认证" class="headerlink" title="单向认证和双向认证"></a>单向认证和双向认证</h3><p>单向认证 客户端保存服务端的公钥，相当于只验证服务端是否安全。<br>双向认证 客服端保存服务端公钥，服务端保存客户端公钥，相互验证。</p><h2 id="OC-如何实现-HTTPS"><a href="#OC-如何实现-HTTPS" class="headerlink" title="OC 如何实现 HTTPS"></a>OC 如何实现 HTTPS</h2><h3 id="使用-NSURLSession"><a href="#使用-NSURLSession" class="headerlink" title="使用 NSURLSession"></a>使用 NSURLSession</h3><p>当使用 NSURLSession 发起时，会回调下面的方法：    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,challenge.protectionSpace);</span><br><span class="line"></span><br><span class="line">    if (![challenge.protectionSpace.authenticationMethod isEqualToString:@&quot;NSURLAuthenticationMethodServerTrust&quot;]) </span><br><span class="line">    return;</span><br><span class="line">    /*</span><br><span class="line">     NSURLSessionAuthChallengeUseCredential 使用证书</span><br><span class="line">     NSURLSessionAuthChallengePerformDefaultHandling  忽略证书 默认的做法</span><br><span class="line">     NSURLSessionAuthChallengeCancelAuthenticationChallenge 取消请求,忽略证书</span><br><span class="line">     NSURLSessionAuthChallengeRejectProtectionSpace 拒绝,忽略证书</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    NSURLCredential *credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line"></span><br><span class="line">    completionHandler(NSURLSessionAuthChallengeUseCredential,credential);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-AF"><a href="#使用-AF" class="headerlink" title="使用 AF"></a>使用 AF</h3><p>AF 内部已经对 HTTPS 进行了处理，单向认证的时候:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//在你封装的网络工具类请求前初始化时增加以下代码</span><br><span class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class="line">//设置证书模式，AFSSLPinningModeNone，代表前端包内不验证</span><br><span class="line">//在单向认证时，前端不放证书，服务器去验证</span><br><span class="line">AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone];</span><br><span class="line">// 如果是需要服务端验证证书，需要设置为YES</span><br><span class="line">securityPolicy.allowInvalidCertificates = YES;</span><br><span class="line">//validatesDomainName 是否需要验证域名，默认为YES；</span><br><span class="line">securityPolicy.validatesDomainName = NO;</span><br><span class="line">//设置验证模式</span><br><span class="line">manager.securityPolicy = securityPolicy;</span><br></pre></td></tr></table></figure><p>双向认证的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//在你封装的网络工具类请求前初始化时增加以下代</span><br><span class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class="line">//设置验证证书，该模式下许愿把证书打包进项目里，进行验证</span><br><span class="line">AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];</span><br><span class="line">//证书的路径</span><br><span class="line">NSString *cerPath = [[NSBundle mainBundle] pathForResource:@&quot;xxx&quot; ofType:@&quot;.cer&quot;];</span><br><span class="line">NSData *dataSou = [NSData dataWithContentsOfFile:cerPath];</span><br><span class="line">NSSet *set = [NSSet setWithObjects:dataSou, nil];</span><br><span class="line">securityPolicy.allowInvalidCertificates = YES;</span><br><span class="line">securityPolicy.validatesDomainName = YES;</span><br><span class="line">[securityPolicy setPinnedCertificates:set];</span><br><span class="line">//将验证方式赋值给管理者</span><br><span class="line">manager.securityPolicy = securityPolicy;</span><br></pre></td></tr></table></figure><h2 id="Charles-如何进行的-HTTPS-抓包"><a href="#Charles-如何进行的-HTTPS-抓包" class="headerlink" title="Charles 如何进行的 HTTPS 抓包"></a>Charles 如何进行的 HTTPS 抓包</h2><p>Charles 抓取 HTTPS 的前提是客户端必须信任 Charles 证书。<br>使用 Charles 后：  </p><ol><li>Charles 作为中间人，代替客户端向服务端请求数据。</li><li>服务端返回公钥证书后，Charles 将公钥保存，然后用自己的公钥制作证书，将证书发给客户端。</li><li>客户端获取 Charles 公钥证书后，必须选择信任，不然会中断连接，然后将对称加密私钥通过 Charles 公钥进行加密后传给 Charles。</li><li>Charles 用自己的 私钥进行解密，获取到 对称加密私钥，然后用服务器的公钥进行加密传给服务器。</li><li>服务器用自己的私钥进行解密，获取到 对称加密私钥。</li><li>至此 Charles 获取到了 对称加密密钥 和 服务器公钥，就可以进行发送数据和解密了。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相对于 HTTP 协议，HTTPS 会花费更多的时间，消耗更多的 CPU 资源，所以比较好的方式是在需要更安全的地方，使用 HTTPS 做数据传输。<br>单向认证更加灵活，客户端不需要把相应的证书打包进入 APP 内，这个证书是有过期时间的。<br>双向认证更加安全。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符编码(转)</title>
      <link href="/2017/05/12/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81-%E8%BD%AC/"/>
      <url>/2017/05/12/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81-%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是字符集"><a href="#什么是字符集" class="headerlink" title="什么是字符集"></a>什么是字符集</h2><p>在介绍字符集之前，我们先了解下为什么要有字符集。我们在计算机屏幕上看到的是实体化的文字，而在计算机存储介质中存放的实际是二进制的比特流。那 么在这两者之间的转换规则就需要一个统一的标准，否则把我们的U盘插到老板的电脑上，文档就乱码了；小伙伴QQ上传过来的文件，在我们本地打开又乱码了。<a id="more"></a> 于是为了实现转换标准，各种字符集标准就出现了。简单的说字符集就规定了某个文字对应的二进制数字存放方式（编码）和某串二进制数值代表了哪个文字（解 码）的转换关系。  </p><p>那么为什么会有那么多字符集标准呢？这个问题实际非常容易回答。问问自己为什么我们的插头拿到英国就不能用了呢？为什么显示器同时有 DVI，VGA，HDMI，DP这么多接口呢？很多规范和标准在最初制定时并不会意识到这将会是以后全球普适的准则，或者处于组织本身利益就想从本质上区 别于现有标准。于是，就产生了那么多具有相同效果但又不相互兼容的标准了。  </p><p>说了那么多我们来看一个实际例子，下面就是屌这个字在各种编码下的十六进制和二进制编码结果，怎么样有没有一种很屌的感觉？  </p><p>字符集      16进制编码    对应的二进制数据<br>UTF-8      0xE5B18C    1110 0101 1011 0001 1000 1100<br>UTF-16      0x5C4C       1011 1000 1001 1000<br>GBK         0x8CC5       1000 1100 1100 0101</p><h2 id="什么是字符编码"><a href="#什么是字符编码" class="headerlink" title="什么是字符编码"></a>什么是字符编码</h2><p>字符集只是一个规则集合的名字，对应到真实生活中，字符集就是对某种语言的称呼。例如：英语，汉语，日语。对于一个字符集来说要正确编码转码一个字 符需要三个关键元素：字库表（character repertoire）、编码字符集（coded character set）、字符编码（character encoding form）。其中字库表是一个相当于所有可读或者可显示字符的数据库，字库表决定了整个字符集能够展现表示的所有字符的范围。编码字符集，即用一个编码值 code point来表示一个字符在字库中的位置。字符编码，将编码字符集和实际存储数值之间的转换关系。一般来说都会直接将code point的值作为编码后的值直接存储。例如在ASCII中A在表中排第65位，而编码后A的数值是0100 0001也即十进制的65的二进制转换结果。  </p><p>看到这里，可能很多读者都会有和我当初一样的疑问：字库表和编码字符集看来是必不可少的，那既然字库表中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。为什么还要多此一举通过字符编码把序号转换成另外一种存储格式呢？  </p><p>其实原因也比较容易理解：统一字库表的目的是为了能够涵盖世界上所有的字符，但实际使用过程中会发现真正用的上的字符相对整个字库表来说比例非常 低。例如中文地区的程序几乎不会需要日语字符，而一些英语国家甚至简单的ASCII字库表就能满足基本需求。而如果把每个字符都用字库表中的序号来存储的 话，每个字符就需要3个字节（这里以Unicode字库为例），这样对于原本用仅占一个字符的ASCII编码的英语地区国家显然是一个额外成本（存储体积 是原来的三倍）。算的直接一些，同样一块硬盘，用ASCII可以存1500篇文章，而用3字节Unicode序号存储只能存500篇。于是就出现了 UTF-8这样的变长编码。在UTF-8编码中原本只需要一个字节的ASCII字符，仍然只占一个字节。而像中文及日语这样的复杂字符就需要2个到3个字 节来存储。  </p><h2 id="UTF-8和Unicode的关系"><a href="#UTF-8和Unicode的关系" class="headerlink" title="UTF-8和Unicode的关系"></a>UTF-8和Unicode的关系</h2><p>看完上面两个概念解释，那么解释UTF-8和Unicode的关系就比较简单了。Unicode就是上文中提到的编码字符集，而UTF-8就是字符 编码，即Unicode规则字库的一种实现形式。随着互联网的发展，对同一字库集的要求越来越迫切，Unicode标准也就自然而然的出现。它几乎涵盖了 各个国家语言可能出现的符号和文字，并将为他们编号。详见：Unicode on Wikipedia。  </p><p>Unicode的编号从0000开始一直到10FFFF共分为16个Plane，每个Plane中有65536个字符。而UTF-8则只实现了第一 个Plane，可见UTF-8虽然是一个当今接受度最广的字符集编码，但是它并没有涵盖整个Unicode的字库，这也造成了它在某些场景下对于特殊字符 的处理困难（下文会有提到）。  </p><h2 id="UTF-8编码简介"><a href="#UTF-8编码简介" class="headerlink" title="UTF-8编码简介"></a>UTF-8编码简介</h2><p>为了更好的理解后面的实际应用，我们这里简单的介绍下UTF-8的编码实现方法。即UTF-8的物理存储和Unicode序号的转换关系。  </p><p>UTF-8编码为变长编码。最小编码单位（code unit）为一个字节。一个字节的前1-3个bit为描述性部分，后面为实际序号部分。<br>如果一个字节的第一位为0，那么代表当前字符为单字节字符，占用一个字节的空间。0之后的所有部分（7个bit）代表在Unicode中的序号。  </p><p>如果一个字节以110开头，那么代表当前字符为双字节字符，占用2个字节的空间。110之后的所有部分（7个bit）代表在Unicode中的序号。且第二个字节以10开头<br>如果一个字节以1110开头，那么代表当前字符为三字节字符，占用2个字节的空间。110之后的所有部分（7个bit）代表在Unicode中的序号。且第二、第三个字节以10开头<br>如果一个字节以10开头，那么代表当前字节为多字节字符的第二个字节。10之后的所有部分（6个bit）代表在Unicode中的序号。  </p><p>具体每个字节的特征可见下表，其中x代表序号部分，把各个字节中的所有x部分拼接在一起就组成了在Unicode字库中的序号  </p><p>Byte 1    Byte 2    Byte3<br>0xxx xxxx<br>110x xxxx    10xx xxxx<br>1110 xxxx    10xx xxxx    10xx xxxx  </p><p>我们分别看三个从一个字节到三个字节的UTF-8编码例子：<br>实际字符    在Unicode字库序号的十六进制    在Unicode字库序号的二进制    UTF-8编码后的二进制    UTF-8编码后的十六进制  </p><p>$    0024    010 0100    0010 0100    24<br>¢    00A2    000 1010 0010    1100 0010 1010 0010    C2 A2<br>€    20AC    0010 0000 1010 1100    1110 0010 1000 0010 1010 1100    E2 82 AC  </p><p>细心的读者不难从以上的简单介绍中得出以下规律：<br>3个字节的UTF-8十六进制编码一定是以E开头的<br>2个字节的UTF-8十六进制编码一定是以C或D开头的<br>1个字节的UTF-8十六进制编码一定是以比8小的数字开头的  </p><h2 id="为什么会出现乱码"><a href="#为什么会出现乱码" class="headerlink" title="为什么会出现乱码"></a>为什么会出现乱码</h2><p>先科普下乱码的英文native说法是mojibake。<br>简单的说乱码的出现是因为：编码和解码时用了不同或者不兼容的字符集。对应到真实生活中，就好比是一个英国人为了表示祝福在纸上写了bless（编 码过程）。而一个法国人拿到了这张纸，由于在法语中bless表示受伤的意思，所以认为他想表达的是受伤（解码过程）。这个就是一个现实生活中的乱码情 况。在计算机科学中一样，一个用UTF-8编码后的字符，用GBK去解码。由于两个字符集的字库表不一样，同一个汉字在两个字符表的位置也不同，最终就会 出现乱码。  </p><p>我们来看一个例子：假设我们用UTF-8编码存储很屌两个字，会有如下转换：<br>字符    UTF-8编码后的十六进制<br>很       E5BE88<br>屌       E5B18C<br>于是我们得到了E5BE88E5B18C这么一串数值。而显示时我们用GBK解码进行展示，通过查表我们获得以下信息：<br>两个字节的十六进制数值    GBK解码后对应的字符<br>E5BE                     寰<br>88E5                     堝<br>B18C                     睂<br>解码后我们就得到了寰堝睂这么一个错误的结果，更要命的是连字符个数都变了。  </p><h2 id="如何识别乱码的本来想要表达的文字"><a href="#如何识别乱码的本来想要表达的文字" class="headerlink" title="如何识别乱码的本来想要表达的文字"></a>如何识别乱码的本来想要表达的文字</h2><p>要从乱码字符中反解出原来的正确文字需要对各个字符集编码规则有较为深刻的掌握。但是原理很简单，这里用最常见的UTF-8被错误用GBK展示时的乱码为例，来说明具体反解和识别过程。  </p><h3 id="第1步-编码"><a href="#第1步-编码" class="headerlink" title="第1步 编码"></a>第1步 编码</h3><p>假设我们在页面上看到寰堝睂这样的乱码，而又得知我们的浏览器当前使用GBK编码。那么第一步我们就能先通过GBK把乱码编码成二进制表达式。当然查表编码效率很低，我们也可以用以下SQL语句直接通过MySQL客户端做编码工作：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql [localhost] &#123;msandbox&#125; &gt; select hex(convert(&apos;寰堝睂&apos; using gbk)); </span><br><span class="line">+-------------------------------------+ </span><br><span class="line">| hex(convert(&apos;寰堝睂&apos; using gbk)) | </span><br><span class="line">+-------------------------------------+ </span><br><span class="line">| E5BE88E5B18C | </span><br><span class="line">+-------------------------------------+ </span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><h3 id="第2步-识别"><a href="#第2步-识别" class="headerlink" title="第2步 识别"></a>第2步 识别</h3><p>现在我们得到了解码后的二进制字符串E5BE88E5B18C。然后我们将它按字节拆开。<br>Byte 1Byte 2Byte 3Byte 4Byte 5Byte 6<br>E5 BE 88 E5 B1 8C<br>然后套用之前UTF-8编码介绍章节中总结出的规律，就不难发现这6个字节的数据符合UTF-8编码规则。如果整个数据流都符合这个规则的话，我们就能大胆假设乱码之前的编码字符集是UTF-8<br>第3步 解码<br>然后我们就能拿着E5BE88E5B18C用UTF-8解码，查看乱码前的文字了。当然我们可以不查表直接通过SQL获得结果：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql [localhost] &#123;msandbox&#125; ((none)) &gt; select convert(0xE5BE88E5B18C using utf8); </span><br><span class="line">+------------------------------------+ </span><br><span class="line">| convert(0xE5BE88E5B18C using utf8) | </span><br><span class="line">+------------------------------------+ </span><br><span class="line">| 很屌 | </span><br><span class="line">+------------------------------------+ </span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="常见问题处理之Emoji"><a href="#常见问题处理之Emoji" class="headerlink" title="常见问题处理之Emoji"></a>常见问题处理之Emoji</h3><p>所谓Emoji就是一种在Unicode位于\u1F601-\u1F64F区段的字符。这个显然超过了目前常用的UTF-8字符集的编码范围\u0000-\uFFFF。Emoji表情随着IOS的普及和微信的支持越来越常见。下面就是几个常见的Emoji:</p><p>那么Emoji字符表情会对我们平时的开发运维带来什么影响呢？最常见的问题就在于将他存入MySQL数据库的时候。一般来说MySQL数据库的默认字符集都会配置成UTF-8（三字节），而utf8mb4在5.5以后才被支持，也很少会有DBA主动将系统默认字符集改成utf8mb4。那么问题就来了，当我们把一个需要4字节UTF-8编码才能表示的字符存入数据库的时候就会报错：ERROR 1366: Incorrect string value: ‘\xF0\x9D\x8C\x86’ for column 。<br>如果认真阅读了上面的解释，那么这个报错也就不难看懂了。我们试图将一串Bytes插入到一列中，而这串Bytes的第一个字节是\xF0意味着这是一个四字节的UTF-8编码。但是当MySQL表和列字符集配置为UTF-8的时候是无法存储这样的字符的，所以报了错。<br>那么遇到这种情况我们如何解决呢？有两种方式：升级MySQL到5.6或更高版本，并且将表字符集切换至utf8mb4。第二种方法就是在把内容存入到数据库之前做一次过滤，将Emoji字符替换成一段特殊的文字编码，然后再存入数据库中。之后从数据库获取或者前端展示时再将这段特殊文字编码转换成Emoji显示。第二种方法我们假设用-<em>-1F601-</em>-来替代4字节的Emoji，那么具体实现python代码可以参见Stackoverflow上的回答。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 的渲染机制以及 UIView 的自动布局流程</title>
      <link href="/2017/03/17/iOS-%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A-UIView-%E7%9A%84%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E6%B5%81%E7%A8%8B/"/>
      <url>/2017/03/17/iOS-%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A-UIView-%E7%9A%84%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>iOS 的界面渲染，是跟 RunLoop 分不开的，屏幕需要更新时，会调用 CPU 协同 GPU ，将界面数据渲染到屏幕上。。。<a id="more"></a></p><h2 id="界面渲染"><a href="#界面渲染" class="headerlink" title="界面渲染"></a>界面渲染</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>同 PC 相似，移动设备也包含屏幕刷新与显卡刷新的概念。iOS 的显示系统，是由 VSync 驱动的，VSync 是用来确定GPU刷新频率和屏幕刷新频率同步的机制。VSync 信号由硬件时钟生成，频率取决于硬件，iPhone 真机上通常是 59.97，有两个缓冲区，即显示缓冲区，简称A、预备缓冲区，简称B，当 VSync 信号到来时，显示器显示 A 中的数据，同时GPU 生成 B 中的数据，并且在显示器显示 A 中数据结束后，将 B 中数据拷贝到 A 中，同时开始绘制下一部分的数据到 B 中。<br>那么是怎么保证这两个频率同步的呢？<br>当屏幕刷新率低于显卡刷新率时，GPU 会进行等待，只有 A 中的数据被显示以后，GPU 才会将数据绘制到 B 中，并在下一次循环中拷贝到 A ，从而显示；<br>当屏幕刷新率高于显卡刷新率时，显卡会暂时显示 A 中的数据，只有等待 B 中数据绘制完整以后，才会将 B 中数据在下一次循环中拷贝到 A。<br>在 VSync 信号到来后，系统的图形服务会通过 CADisplayLink 等机制通知 App ，App 主线程开始执行计算，包括视图创建、布局计算、图片解码、文本绘制等等，然后 CPU 将计算好的内容提交到 GPU ，GPU 去执行变换、合成、渲染。随后 GPU 将渲染结果提交到后备缓冲区 B 。  </p><h3 id="渲染时机"><a href="#渲染时机" class="headerlink" title="渲染时机"></a>渲染时机</h3><p>那么具体体现在 UIView 中是怎样的呢，在代码操作了 UI 时，比如改变了 Frame ，更新了 UIView/CALayer 层次时，或手动调用了 UIView/CALayer 的 setNeedsLayout 、setNeedsDisplay 方法后，这个 UIView/CALayer 就会被标记为待处理状态，并被提交到一个全局的容器中，当 RunLoop 监听到事件被唤醒时(事件可能有多种，比如触摸，动画，timer，或者CADisplayLink等)，CPU 会执行计算，当所有操作结束，RunLoop 即将休眠时，所有的中间状态会被提交到 GPU ，等待下一次 VSync 刷新流程时展示到屏幕上。</p><h2 id="UIView-的自动布局流程-转"><a href="#UIView-的自动布局流程-转" class="headerlink" title="UIView 的自动布局流程(转)"></a>UIView 的自动布局流程(转)</h2><h3 id="大体流程"><a href="#大体流程" class="headerlink" title="大体流程"></a>大体流程</h3><p>基本上分为三步：<br>1.更新约束 (updateConstraints)<br>2.通过约束关系计算出 center 和 bounds 对 subViews 布局(layoutSubViews)<br>3.将布局好的 view 显示到屏幕上 (drawRect)</p><p>与之相关的方法有如下八个：  </p><h4 id="更新约束："><a href="#更新约束：" class="headerlink" title="更新约束："></a>更新约束：</h4><p>1.setNeedsUpdateConstraints：将 view 标记为需要更新约束，并在稍后触发 updateConstraintsIfNeed。<br>2.updateConstraintsIfNeed：系统会在每个布局节点自动调用此方法。只有约束被标记为需要更新才会调用 updateConstraints。此方法可以手动调用，子类不需要重写此方法。<br>3.updateConstraints：更新约束的实际方法。</p><h4 id="布局："><a href="#布局：" class="headerlink" title="布局："></a>布局：</h4><p>1.setNeedsLayout：将 view 标记为需要更新布局，并在稍后触发 layoutIfNeed。当 view 的布局改变时会自动调用。<br>2.layoutIfNeed：系统会在每个布局节点自动调用此方法。只有布局被标记为需要更新时，才会调用 layoutSubViews。<br>3.layoutSubViews：实际布局。</p><h4 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h4><p>1.setNeedsDisplay：将 view 标记为需要重绘，并在下次绘制循环触发 drawRect 。改变布局并不会触发此方法。<br>2.drawRect：绘制，不能直接调用。</p><h3 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h3><p>当你使用 Auto Layout 去努力创造你想要的布局时，特别是同时伴随高级使用场景和动画时，放下使用场景，去回想布局过程是怎样工作的，将会带来很大的帮助。<br>相比使用frame布局，Auto Layout 在 Views 可以被显示之前引入了两个额外的处理工序：更新约束，布局视图<br>每一步都依赖前一步；显示依赖布局，布局依赖约束。</p><h4 id="第一步：更新约束（updateConstraints）"><a href="#第一步：更新约束（updateConstraints）" class="headerlink" title="第一步：更新约束（updateConstraints）"></a>第一步：更新约束（updateConstraints）</h4><p>更新约束可以被认为是一个测量的过程。他从下到上 bottom-up (from subview to super view)去准备在布局时直接设置 views 的 frame 所需要的信息。<br>你可用setNeedsUpdateConstraints手动触发这个过程。也可以通过对自身约束系统的改变来自动触发这个过程。即便这样，当你在定制 views 中改变可能影响布局的的约束时通知 Auto Layout 也是有必要的。<br>说到定制的 views，你可以重写updateConstraints以添加你的 view 在这个阶段需要的局部约束。</p><h4 id="第二步：布局（Layout）"><a href="#第二步：布局（Layout）" class="headerlink" title="第二步：布局（Layout）"></a>第二步：布局（Layout）</h4><p>布局是从上到下 top-down (from super view to subview)进行的。布局的过程事实上是请求约束系统的结果再通过 center 和 bounds 设置给 views。<br>你可以通过调用setNeedsLayout触发这个过程。setNeedsLayout 实际上并没有在接下来立马请求布局，而是把你的请求记录下来随后刷新。<br>通过这种方法你不用担心setNeedsLayout调用太频繁，因为所有的布局请求会被合并到一个布局过程。你可以通过调用layoutIfNeeded来立即触发更新视图层的布局过程，如果你下一步操作依赖于视图最新的布局。<br>在你的定制 view 中你可以通过重写layoutSubviews去获取布局过程的完全控制。我们将在随后展示这样的用法。</p><h4 id="第三部：显示（Display）"><a href="#第三部：显示（Display）" class="headerlink" title="第三部：显示（Display）"></a>第三部：显示（Display）</h4><p>最后，显示过程将 views 渲染到屏幕，这个过程是独立的，不管你用没用 Auto Layout。<br>显示过程从上到下 top-down (from super view to subview) 进行，可以用 setNeedsDisplay 触发，并且会整合所有请求延时重绘。在你的定制 views 重写熟悉的drawRect:方法是你获得 views 在显示过程这个阶段的完全控制的途径。<br>因为每一步都依赖于前一步，所以显示过程将会触发布局过程（如果有任何布局在等待改变）。同样，布局过程将会触发新更新约束过程（如果约束系统有在等到的改变）。<br>需要记住的是，这三个过程的调用顺序并不是唯一的。<br>布局（基于约束 Constraint-based 的）是一个重复的过程。在布局过程中基于上一次布局结果改变约束，将会在下一个布局过程后再次触发约束更新。<br>这将有助于生成 views 高级定制的布局。但是你也有陷入无限循环的风险，如果每个layoutSubviews方法中调用并唤起了另外一个布局过程的话。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>如果想要立即改变约束，需要在setNeedsUpdateConstraints后调用updateConstraintsIfNeeded。<br>如果想要立即改变布局，需要在setNeedsLayout后调用layoutIfNeeded。</p><p>VC 布局时，会从最末级的 view 开始，更新约束，最终调用 VC 的 updateConstraints，然后从 VC 的 viewDidLayoutSubviews 开始，从根到末一级一级的调用子 view 的 layoutSubviews 进行布局，最后从根到末一级一级的调用子 view 的 drawRect 进行绘制。<br>当我们使用 masonry 创建约束以后，被更改的 view 会被调用 setNeedsLayout 标记为需要更新布局，然后 view 会调用 updateConstraints 更新约束，然后调用 layoutSubviews 进行布局。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个简单的SceneKit场景</title>
      <link href="/2017/03/16/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SceneKit%E5%9C%BA%E6%99%AF/"/>
      <url>/2017/03/16/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SceneKit%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>做了一个简单的 SceneKit 场景，即加载动画，并控制动画人物行走，保持摄像机跟随。。。。<a id="more"></a><br>最终效果: <img src="%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SceneKit%E5%9C%BA%E6%99%AF/smapleGif.gif" alt><br>git 传送门 : <a><a href="https://github.com/eassy/TimoRun" target="_blank" rel="noopener">https://github.com/eassy/TimoRun</a></a></p><h2 id="创建一个手柄控制板"><a href="#创建一个手柄控制板" class="headerlink" title="创建一个手柄控制板"></a>创建一个手柄控制板</h2><p>这是控制板最终的样式，中间的按钮只会在触碰的时候显示出来，而且随着手指的移动，中间的按钮在大圈范围内跟随移动。<img src="%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SceneKit%E5%9C%BA%E6%99%AF/gamePad.png" alt><br>自定义一个 UIView ，利用 touchBegin 等一系列的事件检测方法，将触碰点捕捉到，同时判断触碰点是否在大圈范围内，在的话将按钮中心位置挪到触碰点处，不在的话，将按钮中心位置挪到跟触碰点在一个方向的大圈圆周这个点处。有难度的可能是计算按钮中心点最终所处的位置。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)lengthFromA:(CGPoint)aPoint toB:(CGPoint)bPoint</span><br><span class="line">&#123;</span><br><span class="line">    return sqrt((aPoint.x - bPoint.x)*(aPoint.x-bPoint.x) + (aPoint.y-bPoint.y)*(aPoint.y-bPoint.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    self.pad.hidden = NO;</span><br><span class="line">    </span><br><span class="line">    CGPoint point = [[touches anyObject] locationInView:self];</span><br><span class="line">    </span><br><span class="line">    [self movePadCenterToPoint:point animation:NO complete:^&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    CGPoint point = [[touches anyObject] locationInView:self];</span><br><span class="line">    </span><br><span class="line">    [self movePadCenterToPoint:point animation:NO complete:^&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    [self movePadCenterToPoint:CGPointMake(_bigRadius, _bigRadius) animation:YES complete:^&#123;</span><br><span class="line">        self.pad.hidden = YES;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    [self movePadCenterToPoint:CGPointMake(_bigRadius, _bigRadius) animation:YES complete:^&#123;</span><br><span class="line">        self.pad.hidden = YES;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)movePadCenterToPoint:(CGPoint)point animation:(BOOL)animation complete:(void(^)(void))completeBlock</span><br><span class="line">&#123;</span><br><span class="line">    CGFloat length = [self lengthFromA:point toB:CGPointMake(_bigRadius, _bigRadius)];</span><br><span class="line">    CGPoint finalPoint;</span><br><span class="line">    if (length &lt; _bigRadius - _smallRadius) &#123;</span><br><span class="line">        finalPoint = point;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        </span><br><span class="line">        //计算应该的 center</span><br><span class="line">        CGFloat a = (point.x - _bigRadius)/(point.y - _bigRadius);</span><br><span class="line">        CGFloat l = _bigRadius - _smallRadius;</span><br><span class="line">        </span><br><span class="line">        CGFloat offsetY = sqrt(l * l/(a * a + 1));</span><br><span class="line">        if (point.y &gt;= _bigRadius) &#123;</span><br><span class="line">            finalPoint.y = offsetY + _bigRadius;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            finalPoint.y = _bigRadius - offsetY;</span><br><span class="line">        &#125;</span><br><span class="line">        finalPoint.x = a * (finalPoint.y - _bigRadius) + _bigRadius;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (!isnan(finalPoint.x) &amp;&amp; !isnan(finalPoint.y)) &#123;</span><br><span class="line">        self.pad.center = finalPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (completeBlock) &#123;</span><br><span class="line">        completeBlock();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if ([self.delegate respondsToSelector:@selector(padControl:toPoint:)]) &#123;</span><br><span class="line">        [self.delegate padControl:self toPoint:CGPointMake(finalPoint.x - _bigRadius, finalPoint.y - _bigRadius)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算公式不难，大圆中心点位置为 (_bigRadius,_bigRadius),设大圆中心点为(x1,y1),触碰点位置为(x2,y2),最终点为(x,y)，则可列公式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//bigRadius:大圆半径  smallRadius:小圆半径</span><br><span class="line">(x-x1)/(y-y1) = (x2-x1)/(y2-y1)</span><br><span class="line">(x-x1)² + (y-y1)² = (_bigRadius - smallRadius)²</span><br><span class="line">令 l = _bigRadius - _smallRadius;  </span><br><span class="line">   a = (point.x - _bigRadius)/(point.y - _bigRadius);</span><br><span class="line">由此可得 offsetY = |y-y1| = sqrt(l * l/(a * a + 1));</span><br><span class="line">再根据触碰点相对于中心点的方向信息，得出 finalY，最终得出 finalX</span><br></pre></td></tr></table></figure><h2 id="加载文件中的动画和人物"><a href="#加载文件中的动画和人物" class="headerlink" title="加载文件中的动画和人物"></a>加载文件中的动画和人物</h2><p>因为资源文件是带动画的，所以取出来时要先 remove 掉，先保存，后 remove。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)makeTimo</span><br><span class="line">&#123;</span><br><span class="line">    SCNScene *timoScene = [SCNScene sceneNamed:@&quot;art.scnassets/TiMo.DAE&quot;];</span><br><span class="line">    </span><br><span class="line">    self.timoNode = [SCNNode node];</span><br><span class="line">    </span><br><span class="line">    for (SCNNode *childNode in timoScene.rootNode.childNodes) &#123;</span><br><span class="line">        </span><br><span class="line">        [self.timoNode addChildNode:childNode];</span><br><span class="line">        if (childNode.animationKeys.count) &#123;</span><br><span class="line">            self.walkAnimation = [childNode animationForKey:childNode.animationKeys[0]];</span><br><span class="line">            self.walkAnimation.speed = 1.5;</span><br><span class="line">            [childNode removeAllAnimations];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    self.timoNode.position = SCNVector3Make(0, 0.15, 0);</span><br><span class="line">    self.timoNode.scale = SCNVector3Make(0.2, 0.2, 0.2);</span><br><span class="line">    </span><br><span class="line">    SCNPhysicsBody *timoBody = [SCNPhysicsBody kinematicBody];</span><br><span class="line">    timoBody.mass = 10;</span><br><span class="line">    </span><br><span class="line">    self.timoNode.physicsBody = timoBody;</span><br><span class="line">    [self.mainScene.rootNode addChildNode:self.timoNode];</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>物理身体的类型我设置成了 kinematicBody ，因为 设置成动态身体的话根本站不住。。。软趴趴倒在地上哈哈哈。可以看到我将动画保存了起来，然后 remove 掉了。</p><h2 id="创建-Camera-和灯光"><a href="#创建-Camera-和灯光" class="headerlink" title="创建 Camera 和灯光"></a>创建 Camera 和灯光</h2><p>有两个 Camera ，一个是位置一直跟随人物移动的 camera，一个是一直面向人物，但是位置不变的，通过双击屏幕切换这两个视角。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupCamera</span><br><span class="line">&#123;</span><br><span class="line">    // create and add a camera to the scene</span><br><span class="line">    SCNNode *cameraNode = [SCNNode node];</span><br><span class="line">    cameraNode.camera = [SCNCamera camera];</span><br><span class="line">    [self.mainScene.rootNode addChildNode:cameraNode];</span><br><span class="line">    </span><br><span class="line">    // place the camera</span><br><span class="line">    cameraNode.position = SCNVector3Make(0, 50, 60);</span><br><span class="line">    cameraNode.rotation = SCNVector4Make(1, 0, 0, -M_PI / 6.f);</span><br><span class="line">    cameraNode.camera.zFar = 2000;</span><br><span class="line">    self.cameraNode = cameraNode;</span><br><span class="line">    </span><br><span class="line">    ((SCNView *)self.view).pointOfView = self.cameraNode;</span><br><span class="line">    </span><br><span class="line">    SCNNode *thirdCameraNode = [SCNNode node];</span><br><span class="line">    thirdCameraNode.camera = [SCNCamera camera];</span><br><span class="line">    [self.mainScene.rootNode addChildNode:thirdCameraNode];</span><br><span class="line">    thirdCameraNode.position = SCNVector3Make(0, 50, 120);</span><br><span class="line">    thirdCameraNode.rotation = SCNVector4Make(1, 0, 0, -M_PI / 6.f);</span><br><span class="line">    thirdCameraNode.camera.zFar = 2000;</span><br><span class="line">    SCNLookAtConstraint *constraint = [SCNLookAtConstraint lookAtConstraintWithTarget:self.timoNode];</span><br><span class="line">    thirdCameraNode.constraints = @[constraint];</span><br><span class="line">    self.thirdCameraNode = thirdCameraNode;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始的视角是跟随的摄像机。<br>我添加了一个环境光，八个聚焦灯(后面我超想用聚焦灯创建一个ktv那种球状灯的)，灯的方向都是照向地面。</p><h2 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h2><h3 id="创建地板"><a href="#创建地板" class="headerlink" title="创建地板"></a>创建地板</h3><p>创建地板的时候并没有指定大小，好像默认无限大了？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)makeFloor</span><br><span class="line">&#123;</span><br><span class="line">    SCNNode*floor = [SCNNode node];</span><br><span class="line">    floor.geometry = [SCNFloor floor];</span><br><span class="line">    floor.geometry.firstMaterial.diffuse.contents = @&quot;art.scnassets/moss_diffuse.png&quot;;</span><br><span class="line">    floor.geometry.firstMaterial.diffuse.contentsTransform = SCNMatrix4MakeScale(2, 2, 1); //scale the wood texture</span><br><span class="line">    floor.geometry.firstMaterial.locksAmbientWithDiffuse = YES;</span><br><span class="line">    </span><br><span class="line">    SCNPhysicsBody *staticBody = [SCNPhysicsBody staticBody];</span><br><span class="line">    floor.physicsBody = staticBody;</span><br><span class="line">    </span><br><span class="line">    [self.mainScene.rootNode addChildNode:floor];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建四面墙"><a href="#创建四面墙" class="headerlink" title="创建四面墙"></a>创建四面墙</h3><p>创建两面墙，然后使用 clone ，rotate,position 等将墙放在合适的位置。每面墙都是静态躯体。</p><h3 id="创建一个足球"><a href="#创建一个足球" class="headerlink" title="创建一个足球"></a>创建一个足球</h3><p>创建一个球，设置动态物理身体，然后可以被踢着走了~</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenGL-ES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SceneKit开发</title>
      <link href="/2017/03/14/SceneKit%E5%BC%80%E5%8F%91/"/>
      <url>/2017/03/14/SceneKit%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>SceneKit 是 Apple 提供的一个 3D 引擎解决方案，利用它我们不需要跟 OpenGL 打交道，而是直接面向类似于 UIKit 的 API。<a id="more"></a></p><h3 id="SceneKit-使用"><a href="#SceneKit-使用" class="headerlink" title="SceneKit 使用"></a>SceneKit 使用</h3><p>通过创建一个 SceneView ，然后指定其 scene ，添加 相机 节点，并可以控制其动画。像许多 3D 引擎一样， SceneKit 也是有 场景 节点 物理引擎 等一系列的概念。</p><h3 id="加载文件"><a href="#加载文件" class="headerlink" title="加载文件"></a>加载文件</h3><p>SceneKit 最适合的文件类型是 .scn ，同时支持 .dae 。现下各种 3D 制作软件，可以通过安装插件，来导出 .dae 的文件，从中我们可以获取到其中的动画，各种节点，从而添加到我们自己的场景中。需要注意的一点是，我们获取动画的时候，最好能确定动画是加在哪个节点上的，需要跟设计人员进行详细交流。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenGL-ES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL ES 7-画立方体并贴图片</title>
      <link href="/2017/03/01/OpenGL-ES-7/"/>
      <url>/2017/03/01/OpenGL-ES-7/</url>
      
        <content type="html"><![CDATA[<p>绘制立方体跟绘制矩形没什么区别，只是创建好6个面的顶点数组，然后遍历创建矩形就可以了。 <a id="more"></a></p><h3 id="创建顶点数组"><a href="#创建顶点数组" class="headerlink" title="创建顶点数组"></a>创建顶点数组</h3><p>立方体的顶点数组，一共有 6 * 4 = 24 个元素。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">const GLfloat cubeVertices[] = &#123;</span><br><span class="line">        </span><br><span class="line">        // Define the front face</span><br><span class="line">        -1.0, 1.0, 1.0,             // top left</span><br><span class="line">        -1.0, -1.0, 1.0,            // bottom left</span><br><span class="line">        1.0, -1.0, 1.0,             // bottom right</span><br><span class="line">        1.0, 1.0, 1.0,              // top right</span><br><span class="line">        </span><br><span class="line">        // Top face</span><br><span class="line">        -1.0, 1.0, -1.0,            // top left (at rear)</span><br><span class="line">        -1.0, 1.0, 1.0,             // bottom left (at front)</span><br><span class="line">        1.0, 1.0, 1.0,              // bottom right (at front)</span><br><span class="line">        1.0, 1.0, -1.0,             // top right (at rear)</span><br><span class="line">        </span><br><span class="line">        // Rear face</span><br><span class="line">        1.0, 1.0, -1.0,             // top right (when viewed from front)</span><br><span class="line">        1.0, -1.0, -1.0,            // bottom right</span><br><span class="line">        -1.0, -1.0, -1.0,           // bottom left</span><br><span class="line">        -1.0, 1.0, -1.0,            // top left</span><br><span class="line">        </span><br><span class="line">        // bottom face</span><br><span class="line">        -1.0, -1.0, 1.0,</span><br><span class="line">        -1.0, -1.0, -1.0,</span><br><span class="line">        1.0, -1.0, -1.0,</span><br><span class="line">        1.0, -1.0, 1.0,</span><br><span class="line">        </span><br><span class="line">        // left face</span><br><span class="line">        -1.0, 1.0, -1.0,</span><br><span class="line">        -1.0, 1.0, 1.0,</span><br><span class="line">        -1.0, -1.0, 1.0,</span><br><span class="line">        -1.0, -1.0, -1.0,</span><br><span class="line">        </span><br><span class="line">        // right face</span><br><span class="line">        1.0, 1.0, 1.0,</span><br><span class="line">        1.0, 1.0, -1.0,</span><br><span class="line">        1.0, -1.0, -1.0,</span><br><span class="line">        1.0, -1.0, 1.0</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>至今为止，我还没搞懂顺时针和逆时针的顶点顺序到底区别在哪里。。。  </p><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>接下来开始绘制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">glLoadIdentity();</span><br><span class="line">//让视图可见</span><br><span class="line">glTranslatef(0.0, 0.0, -6.0);</span><br><span class="line"></span><br><span class="line">glRotatef(rate, 1.0, 1.0, 1.0);</span><br><span class="line"></span><br><span class="line">glVertexPointer(3, GL_FLOAT, 0, cubeVertices);</span><br><span class="line"></span><br><span class="line">glEnableClientState(GL_VERTEX_ARRAY);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 6; i ++) &#123;</span><br><span class="line">    glColor4f(cubeColors[i*4], cubeColors[i*4 + 1], cubeColors[i*4 + 2], cubeColors[i*4 + 3]);</span><br><span class="line">    glDrawArrays(GL_TRIANGLE_FAN, i * 4, 4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glBindRenderbuffer(GL_RENDERBUFFER, viewRenderbuffer);</span><br><span class="line"></span><br><span class="line">[context presentRenderbuffer:GL_RENDERBUFFER];</span><br></pre></td></tr></table></figure><p>可以看到我们使用一个 for 循环绘制矩形。这次我们可以看到 glDrawArrays() 的第二个参数的用法，这个参数代表了每次取 4 个顶点的时候，数据起点偏移量，第一次为 0 ，第二次为 4 ，以此类推。  </p><h3 id="创建纹理顶点数组"><a href="#创建纹理顶点数组" class="headerlink" title="创建纹理顶点数组"></a>创建纹理顶点数组</h3><p>假如我们想再次绘制纹理到每个面上，不光将图片数据加载到 OpenGL ，我们还需要再创建一个符合六个面的纹理数组，绘制的时候，OpenGL 会去这个数组中查找各个面的对应顶点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//textures</span><br><span class="line">    const GLshort squareTextureCoords[] = &#123;</span><br><span class="line">        // Front face</span><br><span class="line">        0, 1,       // top left</span><br><span class="line">        0, 0,       // bottom left</span><br><span class="line">        1, 0,       // bottom right</span><br><span class="line">        1, 1,       // top right</span><br><span class="line">        </span><br><span class="line">        // Top face</span><br><span class="line">        0, 1,       // top left</span><br><span class="line">        0, 0,       // bottom left</span><br><span class="line">        1, 0,       // bottom right</span><br><span class="line">        1, 1,       // top right</span><br><span class="line">        </span><br><span class="line">        // Rear face</span><br><span class="line">        0, 1,       // top left</span><br><span class="line">        0, 0,       // bottom left</span><br><span class="line">        1, 0,       // bottom right</span><br><span class="line">        1, 1,       // top right</span><br><span class="line">        </span><br><span class="line">        // Bottom face</span><br><span class="line">        0, 1,       // top left</span><br><span class="line">        0, 0,       // bottom left</span><br><span class="line">        1, 0,       // bottom right</span><br><span class="line">        1, 1,       // top right</span><br><span class="line">        </span><br><span class="line">        // Left face</span><br><span class="line">        0, 1,       // top left</span><br><span class="line">        0, 0,       // bottom left</span><br><span class="line">        1, 0,       // bottom right</span><br><span class="line">        1, 1,       // top right</span><br><span class="line">        </span><br><span class="line">        // Right face</span><br><span class="line">        0, 1,       // top left</span><br><span class="line">        0, 0,       // bottom left</span><br><span class="line">        1, 0,       // bottom right</span><br><span class="line">        1, 1,       // top right</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    glTexCoordPointer(2, GL_SHORT, 0, squareTextureCoords);</span><br><span class="line">    glEnableClientState(GL_TEXTURE_COORD_ARRAY);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 6; i ++) &#123;</span><br><span class="line">        glColor4f(cubeColors[i*4], cubeColors[i*4 + 1], cubeColors[i*4 + 2], cubeColors[i*4 + 3]);</span><br><span class="line">        glDrawArrays(GL_TRIANGLE_FAN, i * 4, 4);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>cubeColors[]  是我绘制立方体的时候创建的一个颜色数组，可以忽略，也可以自己创建。</p><h3 id="每个面使用不同纹理图片"><a href="#每个面使用不同纹理图片" class="headerlink" title="每个面使用不同纹理图片"></a>每个面使用不同纹理图片</h3><p>假如我们想立方体的每个面都使用不同的纹理图片，我们肯定需要加载不同的纹理图片，首先，开辟内存的时候就得是 6 个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glGenTextures(6, textures);</span><br></pre></td></tr></table></figure><p>然后我们调用 6 次 loadTextures ，分别将图片名和加载位置传入进去，在 <em>glBindTexture(GL_TEXTURE_2D,location)</em> 时，分别传入 textures[0] ,textures[1] 等等。在我们画图的时候，分别再告诉 OpenGL ，我们将使用不同的纹理图片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 6; i ++) &#123;</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, textures[i]);</span><br><span class="line">    glColor4f(1.0, 1.0, 1.0, 1.0);</span><br><span class="line">    glDrawArrays(GL_TRIANGLE_FAN, i * 4, 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不使用-glLoadIdentity"><a href="#不使用-glLoadIdentity" class="headerlink" title="不使用 glLoadIdentity()"></a>不使用 glLoadIdentity()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">glPushMatrix();</span><br><span class="line">&#123;</span><br><span class="line">    glTexCoordPointer(2, GL_SHORT, 0, squareTextureCoords);</span><br><span class="line">    glEnableClientState(GL_TEXTURE_COORD_ARRAY);</span><br><span class="line">    </span><br><span class="line">    glTranslatef(2.0, 0.0, -8.0);</span><br><span class="line">    </span><br><span class="line">    glRotatef(rate, 1.0, 1.0, 1.0);</span><br><span class="line">    </span><br><span class="line">    glVertexPointer(3, GL_FLOAT, 0, cubeVertices);</span><br><span class="line">    </span><br><span class="line">    glEnableClientState(GL_VERTEX_ARRAY);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 6; i ++) &#123;</span><br><span class="line">        glColor4f(cubeColors[i*4], cubeColors[i*4 + 1], cubeColors[i*4 + 2], cubeColors[i*4 + 3]);</span><br><span class="line">        glDrawArrays(GL_TRIANGLE_FAN, i * 4, 4);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">glPopMatrix();</span><br></pre></td></tr></table></figure><p>glPushMatrix() 与 glPopMatrix() 结对使用，可以让我们丢弃 glLoadIdentity()。<br>1）OpenGL中的modelview矩阵变换是一个马尔科夫过程：上一次的变换结果对本次变换有影响，上次modelview变换后物体在世界坐标系下的位置是本次modelview变换的起点。默认时本次变换和上次变换不独立。<br>2）OpenGL物体建模实际上是分两步走的。第一步，在世界坐标系的原点位置绘制出该物体；第二步，通过modelview变换矩阵对世界坐标系原点处的物体进行仿射变换，将该物体移动到世界坐标系的目标位置处。<br>3）将modelview变换放在glPushMatrix和glPopMatrix之间可以使本次变换和上次变换独立。<br>4）凡是使用glPushMatrix()和glPopMatrix()的程序一般可以判定是采用世界坐标系建模。既世界坐标系固定，modelview矩阵移动物体。</p><h3 id="纹理的使用"><a href="#纹理的使用" class="headerlink" title="纹理的使用"></a>纹理的使用</h3><p>我们可以通过将 4 张图片拼接到一起，不用加载多次，只需要加载一次纹理，然后使用的时候，通过纹理坐标来控制将纹理的哪一部分加载到屏幕上。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenGL-ES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL ES 6-加载图片</title>
      <link href="/2017/02/28/OpenGL-ES-6/"/>
      <url>/2017/02/28/OpenGL-ES-6/</url>
      
        <content type="html"><![CDATA[<p>关于加载图片，需要先将图片数据通过 cgContextRef 加载到内存中，然后再复制到 OpenGL 引擎中，开启纹理绘制。<a id="more"></a></p><h3 id="加载图片到-OpenGL-引擎"><a href="#加载图片到-OpenGL-引擎" class="headerlink" title="加载图片到 OpenGL 引擎"></a>加载图片到 OpenGL 引擎</h3><p>使用 CocoaTouch 的 CGImageRef 和 CGContextRef 来获取图片的位图数据：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">- (void)loadTextures</span><br><span class="line">&#123;</span><br><span class="line">    CGImageRef textureImage = [UIImage imageNamed:@&quot;checkerplate&quot;].CGImage;</span><br><span class="line">    if (textureImage == nil) &#123;</span><br><span class="line">        NSLog(@&quot;Failed to load texture image.&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取到图片的宽高，以便于创建承载图片数据的数组。</span><br><span class="line">    NSInteger texWidth = CGImageGetWidth(textureImage);</span><br><span class="line">    NSInteger texHeight = CGImageGetHeight(textureImage);</span><br><span class="line">    </span><br><span class="line">    //开辟内存空间以存储图片,位图的每一位都是4个字节来保存的 RGBA 数据。即图片是由宽 * 高 个颜色位组成的，每个颜色位为 32 位，4 个字节。</span><br><span class="line">    GLubyte *textureData = (GLubyte *)malloc(texWidth * texHeight * 4);</span><br><span class="line">    //创建一个上下文，句柄，管道,突然有点理解了这两个参数的意思，我们创建一个管道，同时绑定输入和输出，以及管道内通过数据的格式和内容，输出后，这个管道就可以丢弃了。</span><br><span class="line">    CGContextRef textureContext = CGBitmapContextCreate(textureData, texWidth, texHeight, 8, 4 * texWidth, CGImageGetColorSpace(textureImage), kCGImageAlphaPremultipliedLast);</span><br><span class="line">    //将位图的数据存储到数据中</span><br><span class="line">    CGContextDrawImage(textureContext, CGRectMake(0, 0, (float)texWidth, (float)texHeight), textureImage);</span><br><span class="line">    //存储完成，释放 context 的内存。</span><br><span class="line">    CGContextRelease(textureContext);</span><br><span class="line">    </span><br><span class="line">    //为 textures 开辟内存</span><br><span class="line">    glGenTextures(1,&amp;textures[0]);</span><br><span class="line">    </span><br><span class="line">    //激活纹理,并将 textures 的指针传递过去，之后复制纹理数据到 OpenGL 的时候，会自动存放到这个指针中开头的数组中，关于内存空间的开辟，应该是在下一步做的。</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, textures[0]);</span><br><span class="line">    </span><br><span class="line">    //将图片数据复制到 OpenGL 引擎中，应该是在这一步定义了数据的</span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D,         //通常是 GL_TEXTURE_2D</span><br><span class="line">                 0,                     //规定纹理的详细程度。0表示允许图片的全部细节。</span><br><span class="line">                 GL_RGBA,               //通常是 GL_RGBA</span><br><span class="line">                 texWidth,              //数据的宽</span><br><span class="line">                 texHeight,             //数据的高</span><br><span class="line">                 0,                     //border ，必须设置为 0，OpenGL ES 不支持纹理边界</span><br><span class="line">                 GL_RGBA,               //通常是 GL_RGBA</span><br><span class="line">                 GL_UNSIGNED_BYTE,      //每个像素的数据类型，</span><br><span class="line">                 textureData);          //源数据的指针</span><br><span class="line">    </span><br><span class="line">    //复制以后，我们之前保存图片数据的 textureData 也没有用了，可以释放。</span><br><span class="line">    free(textureData);</span><br><span class="line">    </span><br><span class="line">    //告诉 OpenGL ，当距离变大，即缩小的时候(GL_TEXTURE_MIN_FILTER)，该怎么处理</span><br><span class="line">    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    //告诉 OpenGL ，当距离变小，即放大的时候(GL_TEXTURE_MAG_FILTER)，该怎么处理，为了映射纹理，最好都设置一下，</span><br><span class="line">    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    </span><br><span class="line">    //启用 OpenGL 纹理</span><br><span class="line">    glEnable(GL_TEXTURE_2D);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码将纹理数据放到了 OpenGL 中，之后使用的时候，将会自动将纹理渲染到具体位置上。</p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    //纹理渲染坐标数组</span><br><span class="line">    const GLshort squareTextureCoords[] = &#123;</span><br><span class="line">        0, 1,       // top left</span><br><span class="line">        0, 0,       // bottom left</span><br><span class="line">        1, 0,       // bottom right</span><br><span class="line">        1, 1        // top right</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    glColor4f(1.0, 1.0, 1.0, 1.0);</span><br><span class="line">    glTranslatef(1.5, 0.0, -6.0);</span><br><span class="line">    glRotatef(rate, 0.0, 0.0, 1.0);</span><br><span class="line">    glVertexPointer(3, GL_FLOAT, 0, squareVertices);</span><br><span class="line">    </span><br><span class="line">    glEnableClientState(GL_VERTEX_ARRAY);</span><br><span class="line">    glTexCoordPointer(2, GL_SHORT, 0, squareTextureCoords);</span><br><span class="line">    </span><br><span class="line">    glEnableClientState(GL_TEXTURE_COORD_ARRAY);</span><br><span class="line">    </span><br><span class="line">//    glColorPointer(4, GL_FLOAT, 0, squareColours);      // NEW</span><br><span class="line">//    glEnableClientState(GL_COLOR_ARRAY);                // NEW</span><br><span class="line">    glDrawArrays(GL_TRIANGLE_FAN, 0, 4);</span><br><span class="line">//    glDisableClientState(GL_COLOR_ARRAY);               // NEW</span><br><span class="line">    glDisableClientState(GL_TEXTURE_COORD_ARRAY);</span><br><span class="line">    </span><br><span class="line">    glBindRenderbuffer(GL_RENDERBUFFER, viewRenderbuffer);</span><br></pre></td></tr></table></figure><p>glEnableClientState(GL_TEXTURE_COORD_ARRAY); 告诉 OpenGL 开启纹理渲染。<br>glTexCoordPointer(2, GL_SHORT, 0, squareTextureCoords);<br>告诉 OpenGL 我们纹理的坐标，以及每个坐标点的顶点个数，数据类型，从而能准确定位到模型坐标。具体实现细节不清楚，但是 OpenGL 应该是根据纹理的顶点数据，将图片纹理中的数据点与原来的图像数据点进行换算，图片纹理大小将会适应我们的原图。<br>glDisableClientState(GL_TEXTURE_COORD_ARRAY); 关闭纹理，防止影响到三角形。</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>需要注意的或者是需要了解的是：<br>OpenGL 是如何将纹理与原来的图像颜色混合起来的：<br>每个像素点，原来坐标点像素点 rgba 值，乘以图片纹理的 rgba 值。<br>假如原图有个像素点是 1.0 1.0 0.0 1.0<br>图片纹理对应的像素点 1.0 1.0 1.0 1.0，<br>那么最后的像素点为: 1.0 1.0 0.0 1.0 即1.0 * 1.0， 1.0 * 1.0，0.0 * 1.0，1.0 * 1.0 ，所以代码中，使用 glClearColor(1.0,1.0,1.0,1.0) 设置了原图颜色为白色，这样就原封不动的贴上去了纹理。  </p><p>还有一个，我们可以使用自己的纹理图片，但是需要保证这个纹理图片的尺寸，必须是 2 的幂数，比如 1 2 4 8 等等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenGL-ES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL ES 5 渲染颜色</title>
      <link href="/2017/02/28/OpenGL-ES-5/"/>
      <url>/2017/02/28/OpenGL-ES-5/</url>
      
        <content type="html"><![CDATA[<p>同时显示三角形和矩形，同时移动它们，即坐标转换。将物体设置为多重颜色，即彩色。<a id="more"></a>  </p><h2 id="模型转换"><a href="#模型转换" class="headerlink" title="模型转换"></a>模型转换</h2><p>在 OpenGL ES 中，对模型的转换有三种不同类型，分别是：<br>1.Translate 移动模型的坐标，方法：glTranslate()<br>2.Rotate 在 x, y, z 坐标轴上进行旋转,方法：glRotatef()。<br>3.Scale 改变物体的尺寸，主要应用于在 3D 空间中的 2D 投影,方法：glScalef()。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//工作在顶点模式下</span><br><span class="line">    glMatrixMode(GL_MODELVIEW);</span><br><span class="line"> //重置所有的状态</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    glTranslatef(-1.5, 0.0, -6.0);</span><br><span class="line">    glRotatef(rate, 1.0, 0.0, 0.0);</span><br><span class="line">glVertexPointer(3, GL_FLOAT, 0, triangleVertices);</span><br><span class="line">    glEnableClientState(GL_VERTEX_ARRAY);</span><br><span class="line">    glDrawArrays(GL_TRIANGLES, 0, 3);</span><br><span class="line">    </span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    glTranslatef(1.5, 0.0, -6.0);</span><br><span class="line">    glRotatef(rate, 0.0, 0.0, 1.0);</span><br><span class="line">    glVertexPointer(3, GL_FLOAT, 0, squareVertices);</span><br><span class="line">    glEnableClientState(GL_VERTEX_ARRAY);</span><br><span class="line">    glDrawArrays(GL_TRIANGLE_FAN, 0, 4);</span><br></pre></td></tr></table></figure><p>首先我们必须设置 OpenGL 工作在 顶点模式 下，我们之前使用的是投影模式，对于坐标转换来说，还是需要 顶点模式。<br>glLoadIdentity() 为重置所有状态值，不使用这个方法的话,状态偏移将会不断的增加，发生在 z 轴上的移动越来越大，直到模型偏离我们消失不见。</p><h2 id="模型多重颜色"><a href="#模型多重颜色" class="headerlink" title="模型多重颜色"></a>模型多重颜色</h2><p>模型的着色，实际上也是顶点的着色，我们通过给三角形每个顶点着色，改变了模型的整体着色。<br>着色有两种模式：<br>1.glShadeModel(GL_FLAT);平面着色，使用每个三角形最后顶点的颜色，设置整个三角形的颜色。  </p><ol start="2"><li>glShadeModel(GL_SMOOTH);平滑着色，使用每个顶点的颜色，平滑设置整个三角形的颜色。<br>上代码： </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const GLfloat squareColours[] = &#123;</span><br><span class="line">        1.0, 0.0, 0.0, 1.0,// Red - top left - colour for squareVertices[0]</span><br><span class="line">        0.0, 1.0, 0.0, 1.0,   // Green - bottom left - squareVertices[1]</span><br><span class="line">        0.0, 0.0, 1.0, 1.0,   // Blue - bottom right - squareVerticies[2]</span><br><span class="line">        1.0, 1.0, 0.0, 1.0    // Grey - top right- squareVerticies[3]</span><br><span class="line">    &#125;;</span><br><span class="line">glShadeModel(GL_FLAT);</span><br><span class="line">glLoadIdentity();</span><br><span class="line">glTranslatef(1.5, 0.0, -6.0);</span><br><span class="line">glRotatef(rate, 0.0, 0.0, 1.0);</span><br><span class="line">glVertexPointer(3, GL_FLOAT, 0, squareVertices);</span><br><span class="line">glEnableClientState(GL_VERTEX_ARRAY);</span><br><span class="line">glColorPointer(4, GL_FLOAT, 0, squareColours);      // NEW</span><br><span class="line">    glEnableClientState(GL_COLOR_ARRAY);                // NEW</span><br><span class="line">glDrawArrays(GL_TRIANGLE_FAN, 0, 4);</span><br><span class="line">    glDisableClientState(GL_COLOR_ARRAY);               // NEW</span><br></pre></td></tr></table></figure><p>glColorPointer() 函数接受 4 个参数，分别代表颜色的数目，数据类型，0，和颜色数据数组。<br>我们要开启 OpenGL 的颜色绘制模式，绘制完成后，我们要关闭它，否则会影响到三角形颜色的绘制，值么说来，个人感觉 context 的上下文保存状态可能使用的是栈，每个操作都会压入栈中，我们开启颜色模式，就应该关闭它。  </p><p>下一篇将会介绍加载一个纹理图片。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenGL-ES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL ES 4 画矩形</title>
      <link href="/2017/02/28/OpenGL-ES-4/"/>
      <url>/2017/02/28/OpenGL-ES-4/</url>
      
        <content type="html"><![CDATA[<p>这次我们画一个矩形。<a id="more"></a><br>与画三角形相差不大，我们绘制矩形实际上是通过绘制两次三角形来实现的，比如说有四个点，逆时针 0 1 2 3 ，那么我们通过绘制 0 1 2 和 0 2 3，或者通过绘制 0 1 3 和 0 2 3 都能讲这个矩形画出来，而且，所有的多边形，都可以转换为 n 个三角形，so~ 这将借助 glDrawArrays() 这个函数的特性来实现。</p><h3 id="glDrawArrays"><a href="#glDrawArrays" class="headerlink" title="glDrawArrays()"></a>glDrawArrays()</h3><p>首先我们定义一个矩形顶点数组，当然，长度为 12 ，以便组合成 12/3 = 4 个顶点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">const GLfloat squareVerts[] = &#123;</span><br><span class="line">        -1.0, 1.0, -6.0,            // Top left</span><br><span class="line">        -1.0, -1.0, -6.0,           // Bottom left</span><br><span class="line">        1.0, -1.0, -6.0,            // Bottom right</span><br><span class="line">        1.0, 1.0, -6.0</span><br><span class="line">&#125;;</span><br><span class="line">2.glVertexPointer(3, GL_FLOAT, 0, squareVerts);</span><br><span class="line">3.glEnableClientState(GL_VERTEX_ARRAY);</span><br><span class="line">4.glDrawArrays(GL_TRIANGLE_FAN, 0, 4);</span><br></pre></td></tr></table></figure><p>与三角形不同的是 1. 2. 4. 这三条语句，分别定义了数据本身，数据格式，重点的改动是 <em>glDrawArrays()</em> 这个方法，这个方法接受三个参数，分别是 <em>绘图模式</em> <em>0(暂时是默认值)</em> <em>顶点个数</em> </p><h4 id="绘图模式"><a href="#绘图模式" class="headerlink" title="绘图模式"></a>绘图模式</h4><p>可选的 绘图模式 有以下几种：<br>GL_POINTS<br>GL_LINES<br>GL_LINE_LOOP<br>GL_LINE_STRIP<br>GL_TRIANGLES  //三角<br>GL_TRIANGLE_STRIP  //三角<br>GL_TRIANGLE_FAN  //三角<br>现在我们介绍后面三个，其实后面三个都是三角绘图，不同的模式代表着 OpenGL 在数据数组中取数据时，不同的三角顶点组合方式。<br>GL_TRIANGLES 代表使用三个顶点来组成图形。将使用 0 1 2 来组成一个三角形，完成后，再用下一组的三个顶点来组成三角形，直到数组结束。<br>GL_TRIANGLE_STRIP 每个顶点都和之前两个顶点组成一个三角形，例如：0 1 2 和 1 2 3 这是两个三角形。<br>GL_TRIANGLE_FAN  每两个顶点都和第一个顶点组成一个三角形，例如： 0 1 2 和 0 2 3 这是两个三角形。<br>其实我们绘制矩形，后两种模式都可以使用，只不过区别在于数据中点的顺序，假如一个矩形逆时针顶点是 0 1 2 3 四个点，我们使用 GL_TRIANGLE_STRIP 的话，数据数组中点的顺序应该是： 0 1 3 2 或者 0 3 1 2 ，因为我们需要 0 1 3 和 1 2 3 组合起来；而假如我们使用 GL_TRIANGLE_FAN 的话，点的顺序应该是 0 1 2 3，这样 OpenGL 将分隔为 0 1 2 和 0 2 3 两个三角形，正好是个矩形。所以我们需要注意保持顶点数组和绘制模式的一致。<br>下次我们会给目标上色，并移动它们。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenGL-ES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL ES 3 画三角形</title>
      <link href="/2017/02/28/OpenGL-ES-3/"/>
      <url>/2017/02/28/OpenGL-ES-3/</url>
      
        <content type="html"><![CDATA[<p>教程我是根据西蒙的教程走的，他之前用的是 OpenGL 1，我们可以改为 OpenGL 2，只要别忘记初始化 context 时，版本选择 2 就好了。<br>这次我们在屏幕上画一个 三角形。<a id="more"></a><br>首先，我们清除一下缓冲区缓存：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//1.</span><br><span class="line">const GLfloat triangleVertices[] = &#123;</span><br><span class="line">        0.0, 1.0, -9.0, // Triangle top centre</span><br><span class="line">        -1.0, -1.0, -6.0, // bottom left</span><br><span class="line">        1.0, -1.0, -6.0, // bottom right</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">//2.</span><br><span class="line">glVertexPointer(3, GL_FLOAT, 0, triangleVertices);</span><br><span class="line">//3.</span><br><span class="line">glEnableClientState(GL_VERTEX_ARRAY);</span><br><span class="line">//4.</span><br><span class="line">glDrawArrays(GL_TRIANGLE, 0, 3);</span><br><span class="line">//5.</span><br><span class="line">glBindRenderbuffer(GL_RENDERBUFFER, viewRenderbuffer);</span><br><span class="line">//6.</span><br><span class="line">[context presentRenderbuffer:GL_RENDERBUFFER];</span><br></pre></td></tr></table></figure><p>1.我们定义了一个长度为 9 的数组，数组中每三个元素定义一个顶点坐标 x, y, z。<br>2.告诉 OpenGL 我们的数据是什么格式，每个坐标有 3 个数组，float 类型，0是默认的，squareVerts 代表数据本身。<br>3.通知 OpenGL 我们将开启顶点绘制功能。<br>4.开启绘制，第一个参数代表我们将绘制一个三角形，第二个也是默认 0 ，第三个代表我们将绘制三个顶点，同理，四边形就是 4。<br>5.绑定 renderBuffer ，告诉 OpenGL 我们将使用这里面的数据。<br>6.绘制到屏幕上。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenGL-ES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL ES 2 前期准备</title>
      <link href="/2017/02/28/OpenGL-ES-2/"/>
      <url>/2017/02/28/OpenGL-ES-2/</url>
      
        <content type="html"><![CDATA[<p>准备了解一些基本用法，以及如何在项目中使用。<a id="more"></a></p><h2 id="在-iOS-中使用-OpenGL-ES"><a href="#在-iOS-中使用-OpenGL-ES" class="headerlink" title="在 iOS 中使用 OpenGL ES"></a>在 iOS 中使用 OpenGL ES</h2><p>暂时还没了解 CocoaTouch 自带的 GLKit ,所以都是自写的 UIView 去渲染。<br>引入 Frameworks ：  </p><ol><li>QuartzCore.framework  </li><li>OpenGLES.framework  </li></ol><p>OpenGL 渲染时必须需要当前页面层级上有一个 CAEAGLLayer。自定义的UIView 必须实现一个方法：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)layerClass &#123;</span><br><span class="line">    return [CAEAGLLayer class];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个方法将 view 的 layer 转换为 CAEAGLLayer 。  </p><p>使用 OpenGL 引擎还需要有个上下文 context ，我们初始化 context 的同时，还会选择 OpenGL 的 API 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES1];</span><br><span class="line">        //将 context 设置为 currentContext</span><br><span class="line">        if (!context || ![EAGLContext setCurrentContext:context]) &#123;</span><br><span class="line">            [self release];</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>然后就是进行一些必须的初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//必须先创建并且分配内存</span><br><span class="line">- (BOOL)createFramebuffer &#123;</span><br><span class="line">    </span><br><span class="line">    //生成 frameBuffer</span><br><span class="line">    glGenFramebuffers(1, &amp;viewFramebuffer);</span><br><span class="line">    //生成 renderBuffer</span><br><span class="line">    glGenRenderbuffers(1, &amp;viewRenderbuffer);</span><br><span class="line">    //绑定 frameBuffer</span><br><span class="line">    glBindFramebuffer(GL_FRAMEBUFFER, viewFramebuffer);</span><br><span class="line">    //绑定 renderBuffer</span><br><span class="line">    glBindRenderbuffer(GL_RENDERBUFFER, viewRenderbuffer);</span><br><span class="line">    //给 renderBuffer 分配内存</span><br><span class="line">    [context renderbufferStorage:GL_RENDERBUFFER fromDrawable:(CAEAGLLayer*)self.layer];</span><br><span class="line">    //将 renderBuffer 绑定到 frameBuffer 上</span><br><span class="line">    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, viewRenderbuffer);</span><br><span class="line">    //获取屏幕宽度</span><br><span class="line">    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &amp;backingWidth);</span><br><span class="line">    //获取屏幕高度</span><br><span class="line">    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &amp;backingHeight);</span><br><span class="line">    </span><br><span class="line">    //生成 depthRenderBuffer</span><br><span class="line">    if (USE_DEPTH_BUFFER) &#123;</span><br><span class="line">        glGenRenderbuffers(1, &amp;depthRenderbuffer);</span><br><span class="line">        glBindRenderbuffer(GL_RENDERBUFFER, depthRenderbuffer);</span><br><span class="line">        glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, backingWidth, backingHeight);</span><br><span class="line">        glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) &#123;</span><br><span class="line">        NSLog(@&quot;failed to make complete framebuffer object %x&quot;, glCheckFramebufferStatus(GL_FRAMEBUFFER));</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>frameBuffer  和 renderBuffer 是必须的，同时想要 3D 模型更加逼真的话，设置一个 depthRenderBuffer ，通常 帧缓存 frameBuffer 管理着一个或多个 renderBuffer，所以需要将其绑定起来。<br>到这里初始化就完成了，之后会通过 context presentRenderBuffer 我们可以将缓冲区的数据渲染到屏幕上。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenGL-ES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL ES 1 简单介绍</title>
      <link href="/2017/02/27/OpenGL-ES-1/"/>
      <url>/2017/02/27/OpenGL-ES-1/</url>
      
        <content type="html"><![CDATA[<p>OpenGL ES 是访问现代嵌入式系统的 3D 图形加速硬件的一个标准。<a id="more"></a>把几何数据转换为屏幕上的图像的过程叫做渲染。 GPU 控制的缓存是高效渲染的关键。容纳几何数据的缓存定义了要渲染的点、线段和三角形。OpenGL ES 3D 的默认坐标系、顶点和矢量为几何数据的描述提供了数学基础。渲染的结果通常保存在帧缓存中。有两个特别的帧缓存，前帧缓存和后帧缓存，他们控制着屏幕像素的最终颜色。OpenGL ES 的上下文 context 保存了 OpenGL ES 的状态信息，包括用于提供渲染数据的缓存地址和用于接收渲染结果的缓存地址。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenGL-ES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装一个转场动画库</title>
      <link href="/2017/02/21/%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%E5%BA%93/"/>
      <url>/2017/02/21/%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>自从 iOS 7 以后，就可以自定义跳转动画了，苹果开放了相关的 API ，在这里做一个基本的总结。 <a id="more"></a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p> <strong>UIViewControllerTransitioningDelegate</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@protocol UIViewControllerTransitioningDelegate &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line">- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source;</span><br><span class="line"></span><br><span class="line">- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed;</span><br><span class="line"></span><br><span class="line">- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForPresentation:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator;</span><br><span class="line"></span><br><span class="line">- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator;</span><br><span class="line"></span><br><span class="line">- (nullable UIPresentationController *)presentationControllerForPresentedViewController:(UIViewController *)presented presentingViewController:(nullable UIViewController *)presenting sourceViewController:(UIViewController *)source NS_AVAILABLE_IOS(8_0);</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>这个协议中的方法，会在 UIViewController 转场的时候被调用，用来控制是否需要自定义的转场动画。</p><p> <strong>UIViewControllerAnimatedTransitioning</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext;</span><br><span class="line">// This method can only  be a nop if the transition is interactive and not a percentDriven interactive transition.</span><br><span class="line">- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext;</span><br></pre></td></tr></table></figure><p>这个协议就是控制具体的转场动画的实现，包括动画的执行时间，动画的具体执行。</p><p>转场动画主要实现 UIViewController 的这两个协议。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>场景：A present B 。<br>假如现在需要自定义 B 出现和消失时的动画，代码主要写在 B 里面。</p><h3 id="在-B-中将-self-transitioningDelegate-设置成-self；"><a href="#在-B-中将-self-transitioningDelegate-设置成-self；" class="headerlink" title="在 B 中将 self.transitioningDelegate 设置成 self；"></a>在 B 中将 self.transitioningDelegate 设置成 self；</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.transitioningDelegate = self;</span><br><span class="line">self.modalTransitionStyle = UIModalPresentationCustom;</span><br></pre></td></tr></table></figure><h3 id="在-B-中实现协议中的代理方法"><a href="#在-B-中实现协议中的代理方法" class="headerlink" title="在 B 中实现协议中的代理方法:"></a>在 B 中实现协议中的代理方法:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id - (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source</span><br><span class="line">&#123;</span><br><span class="line">    return [[PresentTransition alloc] initWithTransitionType:XWPresentOneTransitionTypePresent];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed</span><br><span class="line">&#123;</span><br><span class="line">    return [[PresentTransition alloc] initWithTransitionType:XWPresentOneTransitionTypeDismiss];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建-PresentTransition-类，并实现-UIViewControllerAnimatedTransitioning-协议"><a href="#创建-PresentTransition-类，并实现-UIViewControllerAnimatedTransitioning-协议" class="headerlink" title="创建 PresentTransition 类，并实现 * UIViewControllerAnimatedTransitioning* 协议"></a>创建 <em>PresentTransition</em> 类，并实现 * UIViewControllerAnimatedTransitioning* 协议</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PresentTransition.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSUInteger, XWPresentOneTransitionType) &#123;</span><br><span class="line">    XWPresentOneTransitionTypePresent = 0,//管理present动画</span><br><span class="line">    XWPresentOneTransitionTypeDismiss//管理dismiss动画</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@interface PresentTransition : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;</span><br><span class="line"></span><br><span class="line">+ (instancetype)transitionWithTransitionType:(XWPresentOneTransitionType)type;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithTransitionType:(XWPresentOneTransitionType)type;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">PresentTransition.m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#import &quot;PresentTransition.h&quot;</span><br><span class="line"></span><br><span class="line">@interface PresentTransition ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic ,assign) XWPresentOneTransitionType type;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation PresentTransition</span><br><span class="line"></span><br><span class="line">+ (instancetype)transitionWithTransitionType:(XWPresentOneTransitionType)type</span><br><span class="line">&#123;</span><br><span class="line">    PresentTransition *transition = [[PresentTransition alloc] initWithTransitionType:type];</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithTransitionType:(XWPresentOneTransitionType)type</span><br><span class="line">&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        _type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">    return 0.7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">    switch (_type) &#123;</span><br><span class="line">        case XWPresentOneTransitionTypePresent:</span><br><span class="line">            [self presentAnimation:transitionContext];</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        case XWPresentOneTransitionTypeDismiss:</span><br><span class="line">            [self dismissAnimation:transitionContext];</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实现present动画逻辑代码</span><br><span class="line">- (void)presentAnimation:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">//获取 VC B</span><br><span class="line">    UIViewController *toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];</span><br><span class="line">    //获取 VC A</span><br><span class="line">    UIViewController *fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];</span><br><span class="line">    //snapshotViewAfterScreenUpdates可以对某个视图截图，我们采用对这个截图做动画代替直接对vc1做动画，因为在手势过渡中直接使用vc1动画会和手势有冲突，    如果不需要实现手势的话，就可以不是用截图视图了，大家可以自行尝试一下</span><br><span class="line">    UIView *tempView = [fromVC.view snapshotViewAfterScreenUpdates:NO];</span><br><span class="line">    tempView.frame = fromVC.view.frame;</span><br><span class="line">    //因为对截图做动画，vc1就可以隐藏了</span><br><span class="line">    fromVC.view.hidden = YES;</span><br><span class="line">    //这里有个重要的概念containerView，如果要对视图做转场动画，视图就必须要加入containerView中才能进行，可以理解containerView管理着所有做转场动画的视图</span><br><span class="line">    UIView *containerView = [transitionContext containerView];</span><br><span class="line">    //将截图视图和vc2的view都加入ContainerView中</span><br><span class="line">    [containerView addSubview:tempView];</span><br><span class="line">    [containerView addSubview:toVC.view];</span><br><span class="line">    //拿到两个视图的 view ，就可以进行具体动画了</span><br><span class="line">    /*动画代码*/</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//实现dismiss动画逻辑代码</span><br><span class="line">- (void)dismissAnimation:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext&#123;</span><br><span class="line">   /*与 present 动画代码相似，只不过 fromVC 和 toVC 变换了*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>实现以后功能，该如何将其封装成一个工具库呢,首先设想一下这个工具库，最简化的版本也应该提供自定义动画的功能。这是我最终的库的结构：<br><img src="%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%E5%BA%93/transition-1.png" alt><br>其中 UIViewController+HJTransition 中代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  UIViewController+HJTransition.h</span><br><span class="line">//  VoucherCollection</span><br><span class="line">//</span><br><span class="line">//  Created by eassy on 17/2/21.</span><br><span class="line">//  Copyright © 2017年 eassy. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &quot;HJTransitionUtilities.h&quot;</span><br><span class="line">#import &quot;HJTransitionAnimator.h&quot;</span><br><span class="line"></span><br><span class="line">@interface UIViewController (HJTransition)</span><br><span class="line"></span><br><span class="line">- (void)hj_presentViewController:(UIViewController *)controller animation:(BOOL)animation animator:(HJTransitionAnimator *)animator;</span><br><span class="line"></span><br><span class="line">- (void)hj_dismissViewController:(UIViewController *)controller animation:(BOOL)animation animator:(HJTransitionAnimator *)animator;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  UIViewController+HJTransition.m</span><br><span class="line">//  VoucherCollection</span><br><span class="line">//</span><br><span class="line">//  Created by eassy on 17/2/21.</span><br><span class="line">//  Copyright © 2017年 eassy. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;UIViewController+HJTransition.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation UIViewController (HJTransition)</span><br><span class="line"></span><br><span class="line">- (void)hj_presentViewController:(UIViewController *)controller animation:(BOOL)animation animator:(HJTransitionAnimator *)animator</span><br><span class="line">&#123;</span><br><span class="line">    controller.transitioningDelegate = animator;</span><br><span class="line">    [self presentViewController:controller animated:animation completion:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)hj_dismissViewController:(UIViewController *)controller animation:(BOOL)animation animator:(HJTransitionAnimator *)animator</span><br><span class="line">&#123;</span><br><span class="line">    controller.transitioningDelegate = animator;</span><br><span class="line">    [self presentViewController:controller animated:animation completion:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>在进行跳转的时候，可以传入自定义的 animator 对象，这个 animator 需要继承自 HJTransitionAnimator 类，其代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  HJTransitionAnimator.h</span><br><span class="line">//  VoucherCollection</span><br><span class="line">//</span><br><span class="line">//  Created by eassy on 17/2/21.</span><br><span class="line">//  Copyright © 2017年 eassy. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;HJTransitionUtilities.h&quot;</span><br><span class="line"></span><br><span class="line">@interface HJTransitionAnimator : NSObject&lt;UIViewControllerTransitioningDelegate,UIViewControllerAnimatedTransitioning&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic ,assign) NSTimeInterval duration;</span><br><span class="line"></span><br><span class="line">- (instancetype)init;</span><br><span class="line"></span><br><span class="line">+ (instancetype)animator;</span><br><span class="line"></span><br><span class="line">- (void)animatePresent:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext;</span><br><span class="line"></span><br><span class="line">- (void)animateDismiss:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  HJTransitionAnimator.m</span><br><span class="line">//  VoucherCollection</span><br><span class="line">//</span><br><span class="line">//  Created by eassy on 17/2/21.</span><br><span class="line">//  Copyright © 2017年 eassy. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;HJTransitionAnimator.h&quot;</span><br><span class="line"></span><br><span class="line">@interface HJTransitionAnimator ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic ,assign) HJAnimationType type;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation HJTransitionAnimator</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        _duration = 0.7;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)animator</span><br><span class="line">&#123;</span><br><span class="line">    return [[[self class] alloc] init];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//子类需重写</span><br><span class="line">- (void)animatePresent:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//子类需重写</span><br><span class="line">- (void)animateDismiss:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - UIViewControllerTransitioningDelegate</span><br><span class="line"></span><br><span class="line">- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source</span><br><span class="line">&#123;</span><br><span class="line">    self.type = HJAnimationTypePresent;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed</span><br><span class="line">&#123;</span><br><span class="line">    self.type = HJAnimationTypeDismiss;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - UIViewControllerAnimatedTransitioning</span><br><span class="line"></span><br><span class="line">- (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">    return self.duration;</span><br><span class="line">&#125;</span><br><span class="line">// This method can only  be a nop if the transition is interactive and not a percentDriven interactive transition.</span><br><span class="line">- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">    if (self.type == HJAnimationTypePresent) &#123;</span><br><span class="line">        [self animatePresent:transitionContext];</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        [self animateDismiss:transitionContext];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>通过继承一个基类，将转场动画中可能出现的细小差别代码分离了出来。下面是自定义的子类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  DirectionTransitionAnimator.h</span><br><span class="line">//  VoucherCollection</span><br><span class="line">//</span><br><span class="line">//  Created by eassy on 17/2/21.</span><br><span class="line">//  Copyright © 2017年 eassy. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;HJTransitionAnimator.h&quot;</span><br><span class="line"></span><br><span class="line">@interface DirectionTransitionAnimator : HJTransitionAnimator</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  DirectionTransitionAnimator.m</span><br><span class="line">//  VoucherCollection</span><br><span class="line">//</span><br><span class="line">//  Created by eassy on 17/2/21.</span><br><span class="line">//  Copyright © 2017年 eassy. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;DirectionTransitionAnimator.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation DirectionTransitionAnimator</span><br><span class="line"></span><br><span class="line">- (void)animateDismiss:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">    //注意在dismiss的时候fromVC就是vc2了，toVC才是VC1了，注意这个关系</span><br><span class="line">    UIViewController *fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];</span><br><span class="line">    UIViewController *toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];</span><br><span class="line">    //参照present动画的逻辑，present成功后，containerView的最后一个子视图就是截图视图，我们将其取出准备动画</span><br><span class="line">    UIView *tempView = [transitionContext containerView].subviews[0];</span><br><span class="line">    //动画吧</span><br><span class="line">    [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^&#123;</span><br><span class="line">        //因为present的时候都是使用的transform，这里的动画只需要将transform恢复就可以了</span><br><span class="line">        fromVC.view.transform = CGAffineTransformIdentity;</span><br><span class="line">        tempView.transform = CGAffineTransformIdentity;</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">        if ([transitionContext transitionWasCancelled]) &#123;</span><br><span class="line">            //失败了标记失败</span><br><span class="line">            [transitionContext completeTransition:NO];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //如果成功了，我们需要标记成功，同时让vc1显示出来，然后移除截图视图，</span><br><span class="line">            [transitionContext completeTransition:YES];</span><br><span class="line">            toVC.view.hidden = NO;</span><br><span class="line">            [tempView removeFromSuperview];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)animatePresent:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">    UIViewController *toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];</span><br><span class="line">    UIViewController *fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];</span><br><span class="line">    //snapshotViewAfterScreenUpdates可以对某个视图截图，我们采用对这个截图做动画代替直接对vc1做动画，因为在手势过渡中直接使用vc1动画会和手势有冲突，    如果不需要实现手势的话，就可以不是用截图视图了，大家可以自行尝试一下</span><br><span class="line">    UIView *tempView = [fromVC.view snapshotViewAfterScreenUpdates:NO];</span><br><span class="line">    tempView.frame = fromVC.view.frame;</span><br><span class="line">    //因为对截图做动画，vc1就可以隐藏了</span><br><span class="line">    fromVC.view.hidden = YES;</span><br><span class="line">    //这里有个重要的概念containerView，如果要对视图做转场动画，视图就必须要加入containerView中才能进行，可以理解containerView管理着所有做转场动画的视图</span><br><span class="line">    UIView *containerView = [transitionContext containerView];</span><br><span class="line">    //将截图视图和vc2的view都加入ContainerView中</span><br><span class="line">    [containerView addSubview:tempView];</span><br><span class="line">    [containerView addSubview:toVC.view];</span><br><span class="line">    //设置vc2的frame，因为这里vc2present出来不是全屏，且初始的时候在底部，如果不设置frame的话默认就是整个屏幕咯，这里containerView的frame就是整个屏幕</span><br><span class="line">    toVC.view.frame = CGRectMake(-containerView.frame.size.width, 0, containerView.frame.size.width, containerView.frame.size.height);</span><br><span class="line">    //开始动画吧，使用产生弹簧效果的动画API</span><br><span class="line">    [UIView animateWithDuration:[self transitionDuration:transitionContext] delay:0 usingSpringWithDamping:0.7 initialSpringVelocity:1.0 / 0.55 options:0 animations:^&#123;</span><br><span class="line">        //首先我们让vc2向上移动</span><br><span class="line">        toVC.view.transform = CGAffineTransformMakeTranslation(containerView.frame.size.width, 0);</span><br><span class="line">        //然后让截图视图缩小一点即可</span><br><span class="line">        tempView.transform = CGAffineTransformMakeScale(0.85, 0.85);</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">        //使用如下代码标记整个转场过程是否正常完成[transitionContext transitionWasCancelled]代表手势是否取消了，如果取消了就传NO表示转场失败，反之亦然，如果不用手势present的话直接传YES也是可以的，但是无论如何我们都必须标记转场的状态，系统才知道处理转场后的操作，否者认为你一直还在转场中，会出现无法交互的情况，切记！</span><br><span class="line">        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];</span><br><span class="line">        //转场失败后的处理</span><br><span class="line">        if ([transitionContext transitionWasCancelled]) &#123;</span><br><span class="line">            //失败后，我们要把vc1显示出来</span><br><span class="line">            fromVC.view.hidden = NO;</span><br><span class="line">            //然后移除截图视图，因为下次触发present会重新截图</span><br><span class="line">            [tempView removeFromSuperview];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>使用的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self hj_presentViewController:voucherListVC animation:YES animator:[DirectionTransitionAnimator animator]];</span><br></pre></td></tr></table></figure><p>通过继承基类，满足了这个库的通用性，同时可以满足自定义。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个有趣的排序算法</title>
      <link href="/2017/02/16/%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2017/02/16/%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>所有 7 位数的正整数，大约有 10000000 个，不会重复，内存可用空间只有 1MB ，进行排序。 <a id="more"></a></p><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>读取一遍文件，然后进行多次归并排序。</p><h3 id="多趟排序"><a href="#多趟排序" class="headerlink" title="多趟排序"></a>多趟排序</h3><p>如果每个号码都用 7 个字节来存储，1 MB 的空间最多存储 143000 个号码，但是假如每个号码用 32 位整数来表示的话(因为是 7 位正整数)，1 MB 的空间可以存储 250000 个号码，这样进行多次读取，第一次读取0 ~ 249999 之间的整数并进行排序，以此类推，读取 40 遍文件，可以完成排序。</p><h3 id="神奇排序"><a href="#神奇排序" class="headerlink" title="神奇排序"></a>神奇排序</h3><p>上面两个方法，一个进行了多次排序，一个进行了多次读取文件，都有弊端。<br>因为排序需求的独特性，可以初始化一个长为 10000000 位的字符串，遍历源文件，假如遍历到整数 n ,就在字符串的第 n 位 置 1。<br>假如待排序文件前 9 位分别是 ：1 5 8 2 7 6 9 3 10，数组遍历完成后字符串为 0 1 1 1 0 1 1 1 1 1，可以看到，排序文件中没有的 4 和 0，在字符串中表现为，第 0 位 和 第 4 位 分别为 0，其他包含的数字置为了 1。<br>这个算法只读取了一次文件，并且有相当的执行效率。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建 CocoaPods 库并上传</title>
      <link href="/2017/02/04/%E5%88%9B%E5%BB%BA-CocoaPods-%E5%BA%93%E5%B9%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2017/02/04/%E5%88%9B%E5%BB%BA-CocoaPods-%E5%BA%93%E5%B9%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p>公司会开发多个 App ，这样创建一个公共的 pod 库是很有必要的，索性昨天趁下班时创建了一个最简单的 pod 库，就把过程记下来吧。<a id="more"></a></p><h2 id="注册-pods-trunk-账号"><a href="#注册-pods-trunk-账号" class="headerlink" title="注册 pods trunk 账号"></a>注册 pods trunk 账号</h2><p>这一步没有什么难度，在终端中注册就好了  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod trunk register houwenjie11@gmail.com &apos;houwenjie&apos; --description=&apos;创建 CocoaPods&apos;</span><br></pre></td></tr></table></figure><p>格式为 pod trunk register <em>github 邮箱</em> <em>‘github 用户名’</em> – description=<em>‘描述’</em><br>接下来就是等待 CocoaPods 给你的邮箱发送确认邮件，点击注册成功，在终端中输入 <em>pod trunk me</em> 可以检验成功与否。值得一提的是。。等待了一个小时这封邮件还没有发送过来，所以这一步可能是需要看人品的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ pod trunk me</span><br><span class="line">  - Name:     eassy  </span><br><span class="line">  - Email:    houwenjie11@gmail.com  </span><br><span class="line">  - Since:    February 3rd, 04:50  </span><br><span class="line">  - Pods:</span><br><span class="line">    - HJTestPods</span><br><span class="line">  - Sessions:</span><br><span class="line">    - February 3rd, 04:50 - June 11th, 20:32. IP: 223.223.202.229</span><br><span class="line">    Description: 创建CocoaPods</span><br></pre></td></tr></table></figure><h2 id="github-上创建项目"><a href="#github-上创建项目" class="headerlink" title="github 上创建项目"></a>github 上创建项目</h2><p>在 github 上创建项目，名字与库的名字相同，<font color="red">不需要生成 readme 和 ignore，也不需要 clone</font>，将项目的地址记录下来就成。</p><h2 id="本地创建-repospec-库"><a href="#本地创建-repospec-库" class="headerlink" title="本地创建 repospec 库"></a>本地创建 repospec 库</h2><h3 id="创建本地库"><a href="#创建本地库" class="headerlink" title="创建本地库"></a>创建本地库</h3><p>这一步可以使用 Cocoapods 提供的一个工具或者叫命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod lib create HJTestPods</span><br></pre></td></tr></table></figure><p>HJTestPods 就是库的名称，执行命令时会让你回答五个问题，分别是使用 1.哪种语言 2.是否需要一个 demo 3.选择一个测试框架 4.是否基于 View 测试 5.类的前缀，我选择的分别是 1.ObjC  2.Yes 3.SPecta 4.Yes 5.HJ。然后他自己会创建项目并生成依赖。<br>这一步会在当前文件夹下面生成一个 HJTestPods 文件夹，里面盛放的就是 Spec Repo 需要的文件目录等，里面有 redeme ignore 等等。  </p><h3 id="将本地库注册到-CocoaPods"><a href="#将本地库注册到-CocoaPods" class="headerlink" title="将本地库注册到 CocoaPods"></a>将本地库注册到 CocoaPods</h3><p>在终端中执行下面命令，将本地库注册到了 CocoaPods</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># pod repo add 库名称 github地址</span><br><span class="line">$ pod repo add HJTestPods https://github.com/eassy/HJTestPods.git</span><br></pre></td></tr></table></figure><h3 id="编辑-podspec-配置文件"><a href="#编辑-podspec-配置文件" class="headerlink" title="编辑 podspec 配置文件"></a>编辑 podspec 配置文件</h3><p>podspec 文件中，记录着库的名称，版本，主页，作者，代码地址等信息，这些参数有些已经定义好了，有些需要去自定义。下面是我创建的库的 podspec 文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># Be sure to run `pod lib lint HJTestPods.podspec&apos; to ensure this is a</span><br><span class="line"># valid spec before submitting.</span><br><span class="line">#</span><br><span class="line"># Any lines starting with a # are optional, but their use is encouraged</span><br><span class="line"># To learn more about a Podspec see http://guides.cocoapods.org/syntax/podspec.html</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">Pod::Spec.new do |s|</span><br><span class="line">  s.name             = &apos;HJTestPods&apos;   ///库的名称</span><br><span class="line">  s.version          = &apos;0.1.0&apos;  ///库的版本，以后升级库的版本号就是编辑这里</span><br><span class="line">  s.summary          = &apos;Just Testing&apos; ///库的描述</span><br><span class="line"></span><br><span class="line"># This description is used to generate tags and improve search results.</span><br><span class="line">#   * Think: What does it do? Why did you write it? What is the focus?</span><br><span class="line">#   * Try to keep it short, snappy and to the point.</span><br><span class="line">#   * Write the description between the DESC delimiters below.</span><br><span class="line">#   * Finally, don&apos;t worry about the indent, CocoaPods strips it!</span><br><span class="line"></span><br><span class="line">  s.description      = &lt;&lt;-DESC</span><br><span class="line">TODO: Add long description of the pod here.    ///长篇描述</span><br><span class="line">                       DESC</span><br><span class="line"></span><br><span class="line">  s.homepage         = &apos;https://github.com/eassy/HJTestPods&apos;  ///库的主页，一般都是 github 的项目主页，也可以写成自己的</span><br><span class="line">  # s.screenshots     = &apos;www.example.com/screenshots_1&apos;, &apos;www.example.com/screenshots_2&apos;</span><br><span class="line">  s.license          = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; &#125;   ///默认生成，必须为 MIT</span><br><span class="line">  s.author           = &#123; &apos;houwenjie_11@163.com&apos; =&gt; &apos;houwenjie11@gmail.com&apos; &#125;   ///库的作者</span><br><span class="line">  s.source           = &#123; :git =&gt; &apos;https://github.com/eassy/HJTestPods.git&apos;, :tag =&gt; s.version.to_s &#125;   ///库的代码地址</span><br><span class="line">  # s.social_media_url = &apos;https://twitter.com/&lt;TWITTER_USERNAME&gt;&apos;</span><br><span class="line"></span><br><span class="line">  s.ios.deployment_target = &apos;7.0&apos;    ///最低支持版本</span><br><span class="line"></span><br><span class="line">  s.source_files = &apos;HJTestPods/Classes/**/*&apos;   ///默认生成</span><br><span class="line">  </span><br><span class="line">  # s.resource_bundles = &#123;</span><br><span class="line">  #   &apos;HJTestPods&apos; =&gt; [&apos;HJTestPods/Assets/*.png&apos;]</span><br><span class="line">  # &#125;</span><br><span class="line"></span><br><span class="line">  # s.public_header_files = &apos;Pod/Classes/**/*.h&apos;</span><br><span class="line">  # s.frameworks = &apos;UIKit&apos;, &apos;MapKit&apos;</span><br><span class="line">  # s.dependency &apos;AFNetworking&apos;, &apos;~&gt; 2.3&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>上面必须要修改的是 s.source s.author s.homepage s.ios.deployment  </p><h3 id="绑定-git-地址并上传-tag"><a href="#绑定-git-地址并上传-tag" class="headerlink" title="绑定 git 地址并上传 tag"></a>绑定 git 地址并上传 tag</h3><p>这步也比较简单 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -s -m &quot;Initial Commit of Library&quot;</span><br><span class="line">$ git remote add origin github地址</span><br><span class="line">$ git push origin master</span><br><span class="line"># 还需要打 tag 并上传</span><br><span class="line">$ git tag -m &quot;first release&quot; &quot;0.1.0&quot;</span><br><span class="line"># git push --tags</span><br></pre></td></tr></table></figure><h3 id="验证-podspec-的正确性"><a href="#验证-podspec-的正确性" class="headerlink" title="验证 podspec 的正确性"></a>验证 podspec 的正确性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod lib lint</span><br></pre></td></tr></table></figure><p>假如看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> -&gt; HJTestPods</span><br><span class="line"> -&gt; HJTestPods (0.2.0)</span><br><span class="line"></span><br><span class="line">HJTestPods passed validation.</span><br></pre></td></tr></table></figure><p>就说明验证通过了，可以下一步上传</p><h2 id="将自己的库上传到-pod"><a href="#将自己的库上传到-pod" class="headerlink" title="将自己的库上传到 pod"></a>将自己的库上传到 pod</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod trunk push cocoaPodsName.podspec</span><br></pre></td></tr></table></figure><p>这一步有可能时间会久一些，成功以后会更新本地的 pod 库。成功后即可开始使用了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三体有感</title>
      <link href="/2017/01/09/%E4%B8%89%E4%BD%93%E6%9C%89%E6%84%9F/"/>
      <url>/2017/01/09/%E4%B8%89%E4%BD%93%E6%9C%89%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<p>“生存是文明的第一需要；文明不断增长和扩张，但宇宙中的物质总量保持不变。”<br>                        ——《三体》<a id="more"></a></p><p>一口气读完三体前两部，竟有种久违的酣畅淋漓，作者以大气磅礴的气势，宏大的叙事风格，为我们讲述了三体的故事。神秘的宇宙中到底有多少文明？黑暗的丛林法则是否真正存在？这些问题让我情不自禁的去思考，去想象，好似作者不是写的科幻小说，而是以见证者的角度向我们慢慢叙述一段历史。</p><p>不同于当下的某些快餐文化，三体虽是科幻，但其中有很多值得让人思考的东西。不管是第一部开头的文革，还是第二部中地球文明与三体文明的博弈，都能让人看到一些东西，让人仿佛置身于那个时代。更不用提作者创作科幻小说的”套路”，记得 序 中，作者刘慈欣被称作中国硬科幻代表，大概是因为作者执着的使用物理法则和潮水般的细节，为我们打造全新的世界，使这些世界栩栩如生的向我们猛扑过来。我时常被小说中的各种术语，各种数据所震撼，对各种未来科技心生向往，纵观近代历史，好似科技的进步，应用，总是会在科幻小说中找到描写的影子，从这个角度看，科幻小说代表着人类对未来的向往，代表着人类想象力的丰满。</p><p>说起来我感觉`，小说最重要的部分，还是穿插于情节之中的，对人类道德、人性的拷问，假如是你处在那个时代，你还会是你么？不知不觉又到12点，还是说晚安吧 <del>。</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
