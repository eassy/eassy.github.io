<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>NSURLProtocol | Eassy</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">NSURLProtocol</h1><a id="logo" href="/.">Eassy</a><p class="description">人性就是用来质疑生活的</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">NSURLProtocol</h1><div class="post-meta">Dec 17, 2018</div><div class="post-content"><p>在 Apple 的文档 <code>URL Loading System</code> 中，详细介绍了一个请求是如何创建、发起、回传数据的，还包括了证书认证，cookie 等一系列的操作，但是好像唯独遗漏了一个特殊的类： <code>NSURLProtocol</code> ，其实在我们日常开发中，是有可能需要跟这个类打交道的，比如网页的缓存，request 重定向等一系列的需求。 <a id="more"></a></p>
<h2 id="关于-Apple-对-NSURLProtocol-的介绍"><a href="#关于-Apple-对-NSURLProtocol-的介绍" class="headerlink" title="关于 Apple 对 NSURLProtocol 的介绍"></a>关于 Apple 对 NSURLProtocol 的介绍</h2><p>每次发起请求时，系统会寻找或者创建一个合适的 <code>protocol</code> 对象来响应 <code>request</code>，而在 <code>protocol</code>中，有一系列的方法会被调用，用来确定是否能够响应这次请求，并且允许通过返回参数来替换原本的请求。<br><code>NSURLProtocol</code>是一个抽象类，里面定义许多发起请求时，系统自动回调的方法。我们需要创建一个继承自 <code>NSURLProtocol</code>的子类，并且实现某些方法，并且将类注册到系统中。系统发起请求时，按照注册的顺序，倒序询问所有的 protocol，假如能处理这次请求的话，就将处理转到这个类中。  </p>
<h2 id="创建一个-Protocol-对象"><a href="#创建一个-Protocol-对象" class="headerlink" title="创建一个 Protocol 对象"></a>创建一个 Protocol 对象</h2><h3 id="initWithRequest-cachedResponse-client"><a href="#initWithRequest-cachedResponse-client" class="headerlink" title="- initWithRequest:cachedResponse:client:"></a>- initWithRequest:cachedResponse:client:</h3><h3 id="initWithTask-cachedResponse-client"><a href="#initWithTask-cachedResponse-client" class="headerlink" title="- initWithTask:cachedResponse:client:"></a>- initWithTask:cachedResponse:client:</h3><p>当我们想在初始化的时候，自定义一些操作的话，我们可以重写上面这俩个方法，但是我们不需要手动调用初始化方法生成对象，这两个方法是系统会自动调用的。</p>
<h2 id="向系统中注册-Protocol-类"><a href="#向系统中注册-Protocol-类" class="headerlink" title="向系统中注册 Protocol 类"></a>向系统中注册 Protocol 类</h2><h3 id="BOOL-registerClass-Class-protocolClass"><a href="#BOOL-registerClass-Class-protocolClass" class="headerlink" title="+ (BOOL)registerClass:(Class)protocolClass"></a>+ (BOOL)registerClass:(Class)protocolClass</h3><p>向系统中注册我们自定义的 <code>protocol</code>，只有这个类不是 <code>NSURLProtocol</code>子类时，这个方法才会返回 NO。当系统发起一次请求时，会按照注册顺序，倒序的调用子类的方法：<code>canInitWithRequest</code> ，第一个返回 YES 的类，会被确定为这次响应的 protocol。  </p>
<h3 id="Important"><a href="#Important" class="headerlink" title="Important"></a>Important</h3><p>需要注意的是，当我们用<code>NSURLProtocol</code>发起请求时，注册方法应该如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">configuration.protocolClasses = @[objc_getClass(<span class="string">"CustomURLProtocol"</span>)];</span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class="keyword">self</span> delegateQueue:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>

<p>需要将自定义的 protocol 注册到 session 的 configuration.protocolClasses 中，才能起作用。</p>
<h3 id="void-unregisterClass-Class-protocolClass"><a href="#void-unregisterClass-Class-protocolClass" class="headerlink" title="+ (void)unregisterClass:(Class)protocolClass"></a>+ (void)unregisterClass:(Class)protocolClass</h3><p>这个方法调用后，该类不再被系统询问。</p>
<h2 id="决定一个-NSURLProtocol-子类是否支持响应某个-request"><a href="#决定一个-NSURLProtocol-子类是否支持响应某个-request" class="headerlink" title="决定一个 NSURLProtocol 子类是否支持响应某个 request"></a>决定一个 NSURLProtocol 子类是否支持响应某个 request</h2><h3 id="BOOL-canInitWithRequest-NSURLRequest-request"><a href="#BOOL-canInitWithRequest-NSURLRequest-request" class="headerlink" title="+ (BOOL)canInitWithRequest:(NSURLRequest *)request"></a>+ (BOOL)canInitWithRequest:(NSURLRequest *)request</h3><p>一个子类必须实现这个方法，来告诉系统，是否由该子类响应这次请求，返回 YES 的话，系统创建该类的对象，并且后续的类方法和对象方法会继续被回调，，返回 NO 的话，系统越过该子类，继续查找。</p>
<h3 id="BOOL-canInitWithTask"><a href="#BOOL-canInitWithTask" class="headerlink" title="+ (BOOL)canInitWithTask"></a>+ (BOOL)canInitWithTask</h3><p>使用 <code>NSURLSession</code>发起请求时，会先调用这个方法，yes 的话，继续调用上面那个方法。功能与上线方法类似。</p>
<h2 id="提供给系统一个标准化的-request"><a href="#提供给系统一个标准化的-request" class="headerlink" title="提供给系统一个标准化的 request"></a>提供给系统一个标准化的 request</h2><p>假如一个子类可以响应一个请求，系统会继续调用下面的方法：</p>
<h3 id="NSURLRequest-canonicalRequestForRequest-NSURLRequest-request"><a href="#NSURLRequest-canonicalRequestForRequest-NSURLRequest-request" class="headerlink" title="+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request"></a>+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request</h3><p>在这个方法中，我们可以返回一个自定义的 request，系统会替换原有的，也可以直接返回原有的 request。</p>
<h2 id="开始和停止请求"><a href="#开始和停止请求" class="headerlink" title="开始和停止请求"></a>开始和停止请求</h2><h3 id="void-startLoading"><a href="#void-startLoading" class="headerlink" title="- (void)startLoading"></a>- (void)startLoading</h3><p>当这个方法被调用时，子类必须发起请求，并通过 client ，将数据回传给系统，系统再将数据传递给本来的监听者。</p>
<h3 id="void-stopLoading"><a href="#void-stopLoading" class="headerlink" title="- (void)stopLoading"></a>- (void)stopLoading</h3><p>这个方法被调用时，子类需要停止自己的请求。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个类是比较简单的一个类，可以当成是，苹果允许的一个中间人攻击，当发起一个请求时，我们可以通过注册 protocol ，替换这次请求，发起我们自己的请求，并通过 client ，将数据传给系统，这一切对 urlSessionDelegate 来说都是透明的。<br><a href="../NSURLProtocol/NSURLProtocol.png">简单的数据流通图</a></p>
</div><div class="tags"><a href="/tags/iOS/">iOS</a></div><div class="post-nav"><a class="pre" href="/2018/12/19/OAStackView/">OAStackView</a><a class="next" href="/2018/12/07/iOS-下的-https-单向和双向认证/">iOS 下的 https 单向和双向认证</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/面试记录/" style="font-size: 15px;">面试记录</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/OpenGL-ES/" style="font-size: 15px;">OpenGL-ES</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/编程/" style="font-size: 15px;">编程</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/OAStackView/">OAStackView</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/17/NSURLProtocol/">NSURLProtocol</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/07/iOS-下的-https-单向和双向认证/">iOS 下的 https 单向和双向认证</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/Apple-文档Authentication-and-Credentials-翻译/">Apple 文档 Authentication and Credentials 的翻译</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/最新-SDWebImage-解读/">最新 SDWebImage 解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/20/RunLoop-CommonModes/">RunLoop-CommonModes</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/NSCondition-锁/">NSCondition 锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/18-11-15-面试复盘/">18.11.15 面试复盘</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/18-11-13-面试复盘/">18.11.13 面试复盘</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/18-11-12-面试复盘/">18.11.12 面试复盘</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Eassy.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>