<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>一个简单的SceneKit场景 | Eassy</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">一个简单的SceneKit场景</h1><a id="logo" href="/.">Eassy</a><p class="description">人性就是用来质疑生活的</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">一个简单的SceneKit场景</h1><div class="post-meta">Mar 16, 2017</div><div class="post-content"><p>做了一个简单的 SceneKit 场景，即加载动画，并控制动画人物行走，保持摄像机跟随。。。。<a id="more"></a><br>最终效果: <img src="%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SceneKit%E5%9C%BA%E6%99%AF/smapleGif.gif" alt><br>git 传送门 : <a><a href="https://github.com/eassy/TimoRun" target="_blank" rel="noopener">https://github.com/eassy/TimoRun</a></a></p>
<h2 id="创建一个手柄控制板"><a href="#创建一个手柄控制板" class="headerlink" title="创建一个手柄控制板"></a>创建一个手柄控制板</h2><p>这是控制板最终的样式，中间的按钮只会在触碰的时候显示出来，而且随着手指的移动，中间的按钮在大圈范围内跟随移动。<img src="%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SceneKit%E5%9C%BA%E6%99%AF/gamePad.png" alt><br>自定义一个 UIView ，利用 touchBegin 等一系列的事件检测方法，将触碰点捕捉到，同时判断触碰点是否在大圈范围内，在的话将按钮中心位置挪到触碰点处，不在的话，将按钮中心位置挪到跟触碰点在一个方向的大圈圆周这个点处。有难度的可能是计算按钮中心点最终所处的位置。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)lengthFromA:(CGPoint)aPoint toB:(CGPoint)bPoint</span><br><span class="line">&#123;</span><br><span class="line">    return sqrt((aPoint.x - bPoint.x)*(aPoint.x-bPoint.x) + (aPoint.y-bPoint.y)*(aPoint.y-bPoint.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    self.pad.hidden = NO;</span><br><span class="line">    </span><br><span class="line">    CGPoint point = [[touches anyObject] locationInView:self];</span><br><span class="line">    </span><br><span class="line">    [self movePadCenterToPoint:point animation:NO complete:^&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    CGPoint point = [[touches anyObject] locationInView:self];</span><br><span class="line">    </span><br><span class="line">    [self movePadCenterToPoint:point animation:NO complete:^&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    [self movePadCenterToPoint:CGPointMake(_bigRadius, _bigRadius) animation:YES complete:^&#123;</span><br><span class="line">        self.pad.hidden = YES;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    [self movePadCenterToPoint:CGPointMake(_bigRadius, _bigRadius) animation:YES complete:^&#123;</span><br><span class="line">        self.pad.hidden = YES;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)movePadCenterToPoint:(CGPoint)point animation:(BOOL)animation complete:(void(^)(void))completeBlock</span><br><span class="line">&#123;</span><br><span class="line">    CGFloat length = [self lengthFromA:point toB:CGPointMake(_bigRadius, _bigRadius)];</span><br><span class="line">    CGPoint finalPoint;</span><br><span class="line">    if (length &lt; _bigRadius - _smallRadius) &#123;</span><br><span class="line">        finalPoint = point;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        </span><br><span class="line">        //计算应该的 center</span><br><span class="line">        CGFloat a = (point.x - _bigRadius)/(point.y - _bigRadius);</span><br><span class="line">        CGFloat l = _bigRadius - _smallRadius;</span><br><span class="line">        </span><br><span class="line">        CGFloat offsetY = sqrt(l * l/(a * a + 1));</span><br><span class="line">        if (point.y &gt;= _bigRadius) &#123;</span><br><span class="line">            finalPoint.y = offsetY + _bigRadius;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            finalPoint.y = _bigRadius - offsetY;</span><br><span class="line">        &#125;</span><br><span class="line">        finalPoint.x = a * (finalPoint.y - _bigRadius) + _bigRadius;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (!isnan(finalPoint.x) &amp;&amp; !isnan(finalPoint.y)) &#123;</span><br><span class="line">        self.pad.center = finalPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (completeBlock) &#123;</span><br><span class="line">        completeBlock();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if ([self.delegate respondsToSelector:@selector(padControl:toPoint:)]) &#123;</span><br><span class="line">        [self.delegate padControl:self toPoint:CGPointMake(finalPoint.x - _bigRadius, finalPoint.y - _bigRadius)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算公式不难，大圆中心点位置为 (_bigRadius,_bigRadius),设大圆中心点为(x1,y1),触碰点位置为(x2,y2),最终点为(x,y)，则可列公式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//bigRadius:大圆半径  smallRadius:小圆半径</span><br><span class="line">(x-x1)/(y-y1) = (x2-x1)/(y2-y1)</span><br><span class="line">(x-x1)² + (y-y1)² = (_bigRadius - smallRadius)²</span><br><span class="line">令 l = _bigRadius - _smallRadius;  </span><br><span class="line">   a = (point.x - _bigRadius)/(point.y - _bigRadius);</span><br><span class="line">由此可得 offsetY = |y-y1| = sqrt(l * l/(a * a + 1));</span><br><span class="line">再根据触碰点相对于中心点的方向信息，得出 finalY，最终得出 finalX</span><br></pre></td></tr></table></figure>

<h2 id="加载文件中的动画和人物"><a href="#加载文件中的动画和人物" class="headerlink" title="加载文件中的动画和人物"></a>加载文件中的动画和人物</h2><p>因为资源文件是带动画的，所以取出来时要先 remove 掉，先保存，后 remove。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)makeTimo</span><br><span class="line">&#123;</span><br><span class="line">    SCNScene *timoScene = [SCNScene sceneNamed:@&quot;art.scnassets/TiMo.DAE&quot;];</span><br><span class="line">    </span><br><span class="line">    self.timoNode = [SCNNode node];</span><br><span class="line">    </span><br><span class="line">    for (SCNNode *childNode in timoScene.rootNode.childNodes) &#123;</span><br><span class="line">        </span><br><span class="line">        [self.timoNode addChildNode:childNode];</span><br><span class="line">        if (childNode.animationKeys.count) &#123;</span><br><span class="line">            self.walkAnimation = [childNode animationForKey:childNode.animationKeys[0]];</span><br><span class="line">            self.walkAnimation.speed = 1.5;</span><br><span class="line">            [childNode removeAllAnimations];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    self.timoNode.position = SCNVector3Make(0, 0.15, 0);</span><br><span class="line">    self.timoNode.scale = SCNVector3Make(0.2, 0.2, 0.2);</span><br><span class="line">    </span><br><span class="line">    SCNPhysicsBody *timoBody = [SCNPhysicsBody kinematicBody];</span><br><span class="line">    timoBody.mass = 10;</span><br><span class="line">    </span><br><span class="line">    self.timoNode.physicsBody = timoBody;</span><br><span class="line">    [self.mainScene.rootNode addChildNode:self.timoNode];</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>物理身体的类型我设置成了 kinematicBody ，因为 设置成动态身体的话根本站不住。。。软趴趴倒在地上哈哈哈。可以看到我将动画保存了起来，然后 remove 掉了。</p>
<h2 id="创建-Camera-和灯光"><a href="#创建-Camera-和灯光" class="headerlink" title="创建 Camera 和灯光"></a>创建 Camera 和灯光</h2><p>有两个 Camera ，一个是位置一直跟随人物移动的 camera，一个是一直面向人物，但是位置不变的，通过双击屏幕切换这两个视角。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupCamera</span><br><span class="line">&#123;</span><br><span class="line">    // create and add a camera to the scene</span><br><span class="line">    SCNNode *cameraNode = [SCNNode node];</span><br><span class="line">    cameraNode.camera = [SCNCamera camera];</span><br><span class="line">    [self.mainScene.rootNode addChildNode:cameraNode];</span><br><span class="line">    </span><br><span class="line">    // place the camera</span><br><span class="line">    cameraNode.position = SCNVector3Make(0, 50, 60);</span><br><span class="line">    cameraNode.rotation = SCNVector4Make(1, 0, 0, -M_PI / 6.f);</span><br><span class="line">    cameraNode.camera.zFar = 2000;</span><br><span class="line">    self.cameraNode = cameraNode;</span><br><span class="line">    </span><br><span class="line">    ((SCNView *)self.view).pointOfView = self.cameraNode;</span><br><span class="line">    </span><br><span class="line">    SCNNode *thirdCameraNode = [SCNNode node];</span><br><span class="line">    thirdCameraNode.camera = [SCNCamera camera];</span><br><span class="line">    [self.mainScene.rootNode addChildNode:thirdCameraNode];</span><br><span class="line">    thirdCameraNode.position = SCNVector3Make(0, 50, 120);</span><br><span class="line">    thirdCameraNode.rotation = SCNVector4Make(1, 0, 0, -M_PI / 6.f);</span><br><span class="line">    thirdCameraNode.camera.zFar = 2000;</span><br><span class="line">    SCNLookAtConstraint *constraint = [SCNLookAtConstraint lookAtConstraintWithTarget:self.timoNode];</span><br><span class="line">    thirdCameraNode.constraints = @[constraint];</span><br><span class="line">    self.thirdCameraNode = thirdCameraNode;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始的视角是跟随的摄像机。<br>我添加了一个环境光，八个聚焦灯(后面我超想用聚焦灯创建一个ktv那种球状灯的)，灯的方向都是照向地面。</p>
<h2 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h2><h3 id="创建地板"><a href="#创建地板" class="headerlink" title="创建地板"></a>创建地板</h3><p>创建地板的时候并没有指定大小，好像默认无限大了？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)makeFloor</span><br><span class="line">&#123;</span><br><span class="line">    SCNNode*floor = [SCNNode node];</span><br><span class="line">    floor.geometry = [SCNFloor floor];</span><br><span class="line">    floor.geometry.firstMaterial.diffuse.contents = @&quot;art.scnassets/moss_diffuse.png&quot;;</span><br><span class="line">    floor.geometry.firstMaterial.diffuse.contentsTransform = SCNMatrix4MakeScale(2, 2, 1); //scale the wood texture</span><br><span class="line">    floor.geometry.firstMaterial.locksAmbientWithDiffuse = YES;</span><br><span class="line">    </span><br><span class="line">    SCNPhysicsBody *staticBody = [SCNPhysicsBody staticBody];</span><br><span class="line">    floor.physicsBody = staticBody;</span><br><span class="line">    </span><br><span class="line">    [self.mainScene.rootNode addChildNode:floor];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建四面墙"><a href="#创建四面墙" class="headerlink" title="创建四面墙"></a>创建四面墙</h3><p>创建两面墙，然后使用 clone ，rotate,position 等将墙放在合适的位置。每面墙都是静态躯体。</p>
<h3 id="创建一个足球"><a href="#创建一个足球" class="headerlink" title="创建一个足球"></a>创建一个足球</h3><p>创建一个球，设置动态物理身体，然后可以被踢着走了~</p>
</div><div class="tags"><a href="/tags/OpenGL-ES/">OpenGL-ES</a></div><div class="post-nav"><a class="pre" href="/2017/03/17/iOS-的渲染机制以及-UIView-的自动布局流程/">iOS 的渲染机制以及 UIView 的自动布局流程</a><a class="next" href="/2017/03/14/SceneKit开发/">SceneKit开发</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/面试记录/" style="font-size: 15px;">面试记录</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/OpenGL-ES/" style="font-size: 15px;">OpenGL-ES</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/编程/" style="font-size: 15px;">编程</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/15/换了电脑，怎么做-hexo-数据迁移？/">换了电脑，怎么做 hexo 数据迁移？</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/OAStackView/">OAStackView</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/17/NSURLProtocol/">NSURLProtocol</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/07/iOS-下的-https-单向和双向认证/">iOS 下的 https 单向和双向认证</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/Apple-文档Authentication-and-Credentials-翻译/">Apple 文档 Authentication and Credentials 的翻译</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/最新-SDWebImage-解读/">最新 SDWebImage 解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/20/RunLoop-CommonModes/">RunLoop-CommonModes</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/NSCondition-锁/">NSCondition 锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/18-11-15-面试复盘/">18.11.15 面试复盘</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/18-11-13-面试复盘/">18.11.13 面试复盘</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Eassy.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>