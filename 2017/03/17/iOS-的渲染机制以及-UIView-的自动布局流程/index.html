<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS 的渲染机制以及 UIView 的自动布局流程 | Eassy</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS 的渲染机制以及 UIView 的自动布局流程</h1><a id="logo" href="/.">Eassy</a><p class="description">人性就是用来质疑生活的</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS 的渲染机制以及 UIView 的自动布局流程</h1><div class="post-meta">Mar 17, 2017</div><div class="post-content"><p>iOS 的界面渲染，是跟 RunLoop 分不开的，屏幕需要更新时，会调用 CPU 协同 GPU ，将界面数据渲染到屏幕上。。。<a id="more"></a></p>
<h2 id="界面渲染"><a href="#界面渲染" class="headerlink" title="界面渲染"></a>界面渲染</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>同 PC 相似，移动设备也包含屏幕刷新与显卡刷新的概念。iOS 的显示系统，是由 VSync 驱动的，VSync 是用来确定GPU刷新频率和屏幕刷新频率同步的机制。VSync 信号由硬件时钟生成，频率取决于硬件，iPhone 真机上通常是 59.97，有两个缓冲区，即显示缓冲区，简称A、预备缓冲区，简称B，当 VSync 信号到来时，显示器显示 A 中的数据，同时GPU 生成 B 中的数据，并且在显示器显示 A 中数据结束后，将 B 中数据拷贝到 A 中，同时开始绘制下一部分的数据到 B 中。<br>那么是怎么保证这两个频率同步的呢？<br>当屏幕刷新率低于显卡刷新率时，GPU 会进行等待，只有 A 中的数据被显示以后，GPU 才会将数据绘制到 B 中，并在下一次循环中拷贝到 A ，从而显示；<br>当屏幕刷新率高于显卡刷新率时，显卡会暂时显示 A 中的数据，只有等待 B 中数据绘制完整以后，才会将 B 中数据在下一次循环中拷贝到 A。<br>在 VSync 信号到来后，系统的图形服务会通过 CADisplayLink 等机制通知 App ，App 主线程开始执行计算，包括视图创建、布局计算、图片解码、文本绘制等等，然后 CPU 将计算好的内容提交到 GPU ，GPU 去执行变换、合成、渲染。随后 GPU 将渲染结果提交到后备缓冲区 B 。  </p>
<h3 id="渲染时机"><a href="#渲染时机" class="headerlink" title="渲染时机"></a>渲染时机</h3><p>那么具体体现在 UIView 中是怎样的呢，在代码操作了 UI 时，比如改变了 Frame ，更新了 UIView/CALayer 层次时，或手动调用了 UIView/CALayer 的 setNeedsLayout 、setNeedsDisplay 方法后，这个 UIView/CALayer 就会被标记为待处理状态，并被提交到一个全局的容器中，当 RunLoop 监听到事件被唤醒时(事件可能有多种，比如触摸，动画，timer，或者CADisplayLink等)，CPU 会执行计算，当所有操作结束，RunLoop 即将休眠时，所有的中间状态会被提交到 GPU ，等待下一次 VSync 刷新流程时展示到屏幕上。</p>
<h2 id="UIView-的自动布局流程-转"><a href="#UIView-的自动布局流程-转" class="headerlink" title="UIView 的自动布局流程(转)"></a>UIView 的自动布局流程(转)</h2><h3 id="大体流程"><a href="#大体流程" class="headerlink" title="大体流程"></a>大体流程</h3><p>基本上分为三步：<br>1.更新约束 (updateConstraints)<br>2.通过约束关系计算出 center 和 bounds 对 subViews 布局(layoutSubViews)<br>3.将布局好的 view 显示到屏幕上 (drawRect)</p>
<p>与之相关的方法有如下八个：  </p>
<h4 id="更新约束："><a href="#更新约束：" class="headerlink" title="更新约束："></a>更新约束：</h4><p>1.setNeedsUpdateConstraints：将 view 标记为需要更新约束，并在稍后触发 updateConstraintsIfNeed。<br>2.updateConstraintsIfNeed：系统会在每个布局节点自动调用此方法。只有约束被标记为需要更新才会调用 updateConstraints。此方法可以手动调用，子类不需要重写此方法。<br>3.updateConstraints：更新约束的实际方法。</p>
<h4 id="布局："><a href="#布局：" class="headerlink" title="布局："></a>布局：</h4><p>1.setNeedsLayout：将 view 标记为需要更新布局，并在稍后触发 layoutIfNeed。当 view 的布局改变时会自动调用。<br>2.layoutIfNeed：系统会在每个布局节点自动调用此方法。只有布局被标记为需要更新时，才会调用 layoutSubViews。<br>3.layoutSubViews：实际布局。</p>
<h4 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h4><p>1.setNeedsDisplay：将 view 标记为需要重绘，并在下次绘制循环触发 drawRect 。改变布局并不会触发此方法。<br>2.drawRect：绘制，不能直接调用。</p>
<h3 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h3><p>当你使用 Auto Layout 去努力创造你想要的布局时，特别是同时伴随高级使用场景和动画时，放下使用场景，去回想布局过程是怎样工作的，将会带来很大的帮助。<br>相比使用frame布局，Auto Layout 在 Views 可以被显示之前引入了两个额外的处理工序：更新约束，布局视图<br>每一步都依赖前一步；显示依赖布局，布局依赖约束。</p>
<h4 id="第一步：更新约束（updateConstraints）"><a href="#第一步：更新约束（updateConstraints）" class="headerlink" title="第一步：更新约束（updateConstraints）"></a>第一步：更新约束（updateConstraints）</h4><p>更新约束可以被认为是一个测量的过程。他从下到上 bottom-up (from subview to super view)去准备在布局时直接设置 views 的 frame 所需要的信息。<br>你可用setNeedsUpdateConstraints手动触发这个过程。也可以通过对自身约束系统的改变来自动触发这个过程。即便这样，当你在定制 views 中改变可能影响布局的的约束时通知 Auto Layout 也是有必要的。<br>说到定制的 views，你可以重写updateConstraints以添加你的 view 在这个阶段需要的局部约束。</p>
<h4 id="第二步：布局（Layout）"><a href="#第二步：布局（Layout）" class="headerlink" title="第二步：布局（Layout）"></a>第二步：布局（Layout）</h4><p>布局是从上到下 top-down (from super view to subview)进行的。布局的过程事实上是请求约束系统的结果再通过 center 和 bounds 设置给 views。<br>你可以通过调用setNeedsLayout触发这个过程。setNeedsLayout 实际上并没有在接下来立马请求布局，而是把你的请求记录下来随后刷新。<br>通过这种方法你不用担心setNeedsLayout调用太频繁，因为所有的布局请求会被合并到一个布局过程。你可以通过调用layoutIfNeeded来立即触发更新视图层的布局过程，如果你下一步操作依赖于视图最新的布局。<br>在你的定制 view 中你可以通过重写layoutSubviews去获取布局过程的完全控制。我们将在随后展示这样的用法。</p>
<h4 id="第三部：显示（Display）"><a href="#第三部：显示（Display）" class="headerlink" title="第三部：显示（Display）"></a>第三部：显示（Display）</h4><p>最后，显示过程将 views 渲染到屏幕，这个过程是独立的，不管你用没用 Auto Layout。<br>显示过程从上到下 top-down (from super view to subview) 进行，可以用 setNeedsDisplay 触发，并且会整合所有请求延时重绘。在你的定制 views 重写熟悉的drawRect:方法是你获得 views 在显示过程这个阶段的完全控制的途径。<br>因为每一步都依赖于前一步，所以显示过程将会触发布局过程（如果有任何布局在等待改变）。同样，布局过程将会触发新更新约束过程（如果约束系统有在等到的改变）。<br>需要记住的是，这三个过程的调用顺序并不是唯一的。<br>布局（基于约束 Constraint-based 的）是一个重复的过程。在布局过程中基于上一次布局结果改变约束，将会在下一个布局过程后再次触发约束更新。<br>这将有助于生成 views 高级定制的布局。但是你也有陷入无限循环的风险，如果每个layoutSubviews方法中调用并唤起了另外一个布局过程的话。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>如果想要立即改变约束，需要在setNeedsUpdateConstraints后调用updateConstraintsIfNeeded。<br>如果想要立即改变布局，需要在setNeedsLayout后调用layoutIfNeeded。</p>
<p>VC 布局时，会从最末级的 view 开始，更新约束，最终调用 VC 的 updateConstraints，然后从 VC 的 viewDidLayoutSubviews 开始，从根到末一级一级的调用子 view 的 layoutSubviews 进行布局，最后从根到末一级一级的调用子 view 的 drawRect 进行绘制。<br>当我们使用 masonry 创建约束以后，被更改的 view 会被调用 setNeedsLayout 标记为需要更新布局，然后 view 会调用 updateConstraints 更新约束，然后调用 layoutSubviews 进行布局。</p>
</div><div class="tags"><a href="/tags/iOS/">iOS</a></div><div class="post-nav"><a class="pre" href="/2017/05/12/字符编码-转/">字符编码(转)</a><a class="next" href="/2017/03/16/一个简单的SceneKit场景/">一个简单的SceneKit场景</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/面试记录/" style="font-size: 15px;">面试记录</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/OpenGL-ES/" style="font-size: 15px;">OpenGL-ES</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/编程/" style="font-size: 15px;">编程</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/15/换了电脑，怎么做-hexo-数据迁移？/">换了电脑，怎么做 hexo 数据迁移？</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/OAStackView/">OAStackView</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/17/NSURLProtocol/">NSURLProtocol</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/07/iOS-下的-https-单向和双向认证/">iOS 下的 https 单向和双向认证</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/Apple-文档Authentication-and-Credentials-翻译/">Apple 文档 Authentication and Credentials 的翻译</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/最新-SDWebImage-解读/">最新 SDWebImage 解读</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/20/RunLoop-CommonModes/">RunLoop-CommonModes</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/NSCondition-锁/">NSCondition 锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/18-11-15-面试复盘/">18.11.15 面试复盘</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/15/18-11-13-面试复盘/">18.11.13 面试复盘</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Eassy.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>